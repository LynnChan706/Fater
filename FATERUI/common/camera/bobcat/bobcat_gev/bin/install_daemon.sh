#!/bin/bash
# ***************************************************************************************
#     Pleora Technologies Inc. Copyright (c) 2002-2015
# ***************************************************************************************
SCRIPT_DIR=`readlink -f $0`
SDK_BIN_DIR=`dirname $SCRIPT_DIR`
SDK_DIR=`cd $SDK_BIN_DIR/..; pwd`
SDK_LIB_DIR="$SDK_DIR/lib"
USER_ID=`id -u`

SERVICE_NAME="eBUSd"
SERVICE_FILE="/etc/init.d/$SERVICE_NAME"
DAEMON_NAME="eBUSd"
DAEMON_FILE="$SDK_BIN_DIR/$DAEMON_NAME"
SERVICE_PID_FILE="/var/run/$SERVICE_NAME.pid"

DisplayHelp()
{
    echo ""
    echo "NAME"
    echo "    install_daemon.sh - Installer for the $SERVICE_NAME daemon."
    echo ""
    echo "SYNOPSIS"
    echo "    bash install_daemon.sh [ --install=manual|auto ][ --uninstall ][ --help ]"
    echo ""
    echo "DESCRIPTION"
    echo "    The eBUS SDK daemon is required to use third-"
    echo "    party receiver, transmitter or USB3 Vision devices."
    echo "    This script can only be used by the root or sudoer account."
    echo "    --install=manual|auto Installs the daemon. "
    echo "                           manual - User will have to manually manage the daemon."
    echo "                           auto - The daemon will automatically start at boot time."
    echo "    --uninstall           Uninstalls the daemon. "
    echo "    --help                Displays this help."
    echo ""
    echo "COPYRIGHT"
    echo "    Pleora Technologies Inc. Copyright (c) 2002-2015"
    echo ""
    echo "VERSION"
    echo "    4.1.4.3606"
    echo ""
}

Install()
{
    if [ "$1" = "Ubuntu" ]; then
        CreateScript_Debian $SERVICE_FILE
    elif [ "$1" = "RH" ]; then
        CreateScript_RH $SERVICE_FILE 
    fi 

    chmod u=rwx,g=rwx,o=rx $SERVICE_FILE
}

CreateScript_Debian()
{

> $1
cat > $1 <<__END__
#! /bin/sh
### BEGIN INIT INFO
# Provides:          $SERVICE_NAME
# Required-Start:    \$remote_fs \$syslog \$local_fs
# Required-Stop:     \$remote_fs \$syslog \$local_fs
# Default-Start:
# Default-Stop:
# Short-Description: Start eBUS SDK daemon at boot time
# Description:       eBUSd is a daemon use to proxy to access the U3V devices.
### END INIT INFO

#
# NAME         
#     eBUSd - Autogenerated eBUS SDK daemon script
#
# DESCRIPTION
#     eBUSd is a daemon use to proxy to access the U3V devices.
#      It is also used to keep trace of the eBUS SDK licenses.
#              
# COPYRIGHT
#     Pleora Technologies Inc. Copyright (c) 2002-2015
#              
# VERSION
#     4.1.4.3606
#              

RETVAL=0

PATH="/sbin:/usr/sbin:/bin:/usr/bin:$SDK_BIN_DIR"

LD_LIBRARY_PATH="$SDK_LIB_DIR"
export LD_LIBRARY_PATH=\$LD_LIBRARY_PATH
export PUREGEV_ROOT="$SDK_DIR"

DESCRIPTION="eBUS SDK Daemon"
NAME="$DAEMON_NAME"
DAEMON="$DAEMON_FILE"
SCRIPTNAME="$SERVICE_NAME"
PIDFILE="$SERVICE_PID_FILE"

# Exit if the package is not installed
[ -x "\$DAEMON" ] || exit 0

# Load the VERBOSE setting and other rcS variables
. /lib/init/vars.sh

# Define LSB log_* functions.
# Depend on lsb-base (>= 3.2-14) to ensure that this file is present
# and status_of_proc is working.
. /lib/lsb/init-functions

#
# Function that starts the daemon/service
#
do_start()
{
	# Return
	#   0 if daemon has been started
	#   1 if daemon was already running
	#   2 if daemon could not be started
	start-stop-daemon --start --quiet --exec \$DAEMON --test > /dev/null \
		|| return 1
	start-stop-daemon --start --quiet --exec \$DAEMON -- --pidfile=\$PIDFILE \
		|| return 2
}

#
# Function that stops the daemon/service
#
do_stop()
{
	# Return
	#   0 if daemon has been stopped
	#   1 if daemon was already stopped
	#   2 if daemon could not be stopped
	#   other if a failure occurred
	start-stop-daemon --stop --quiet --retry=TERM/30/KILL/5 --name \$NAME
	RETVAL="\$?"
	[ "\$RETVAL" = 2 ] && return 2
	# Wait for children to finish too if this is a daemon that forks
	# and if the daemon is only ever run from this initscript.
	# If the above conditions are not satisfied then add some other code
	# that waits for the process to drop all resources that could be
	# needed by services started subsequently.  A last resort is to
	# sleep for some time.
	start-stop-daemon --stop --quiet --oknodo --retry=0/30/KILL/5 --pidfile \$PIDFILE --exec \$DAEMON
	[ "\$?" = 2 ] && return 2
	# Many daemons don't delete their pidfiles when they exit.
	rm -f \$PIDFILE
	return "\$RETVAL"
}

case "\$1" in
  start)
	[ "\$VERBOSE" != no ] && log_daemon_msg "Starting \$DESCRIPTION" "\$NAME"
	do_start
	case "\$?" in
		0|1) [ "\$VERBOSE" != no ] && log_end_msg 0 ;;
		2) [ "\$VERBOSE" != no ] && log_end_msg 1 ;;
	esac
	;;
  stop)
	[ "\$VERBOSE" != no ] && log_daemon_msg "Stopping \$DESCRIPTION" "\$NAME"
	do_stop
	case "\$?" in
		0|1) [ "\$VERBOSE" != no ] && log_end_msg 0 ;;
		2) [ "\$VERBOSE" != no ] && log_end_msg 1 ;;
	esac
	;;
  status)
	status_of_proc "\$DAEMON" "\$NAME" && exit 0 || exit \$?
	;;
  restart|force-reload)
	log_daemon_msg "Restarting \$DESCRIPTION" "\$NAME"
	do_stop
	case "\$?" in
	  0|1)
		do_start
		case "\$?" in
			0) log_end_msg 0 ;;
			1) log_end_msg 1 ;; # Old process is still running
			*) log_end_msg 1 ;; # Failed to start
		esac
		;;
	  *)
		# Failed to stop
		log_end_msg 1
		;;
	esac
	;;
  *)

	echo "Usage: \$SCRIPTNAME {start|stop|restart|status|force-reload}" >&2
	exit 3
	;;
esac

:
__END__
}

CreateScript_RH()
{

> $1
cat > $1 <<__END__
#! /bin/sh
#
#  Start / Stop the $SERVICE_NAME daemon.
#
# chkconfig: 2345 90 60
# description: eBUSd is a daemon use to proxy to access the U3V devices. \
#               It is also used to keep trace of the eBUS SDK licenses. 
#
### BEGIN INIT INFO
# Provides:          $SERVICE_NAME
# Required-Start:    \$remote_fs \$syslog \$local_fs
# Required-Stop:     \$remote_fs \$syslog \$local_fs
# Default-Start:
# Default-Stop:    
# Short-Description: Start eBUS SDK daemon at boot time
# Description:       eBUSd is a daemon use to proxy to access the U3V devices.
### END INIT INFO
#
# NAME         
#     eBUSd - Autogenerated eBUS SDK daemon script
#
# DESCRIPTION
#     eBUSd is a daemon use to proxy to access the U3V devices.
#      It is also used to keep trace of the eBUS SDK licenses.      
#              
# COPYRIGHT
#     Pleora Technologies Inc. Copyright (c) 2002-2015
#              
# VERSION
#     4.1.4.3606
# 

# Source function library.
. /etc/rc.d/init.d/functions

RETVAL=0

PATH="/sbin:/usr/sbin:/bin:/usr/bin:$SDK_BIN_DIR"

LD_LIBRARY_PATH="$SDK_LIB_DIR"
export LD_LIBRARY_PATH=\$LD_LIBRARY_PATH
export PUREGEV_ROOT="$SDK_DIR"

DAEMON="$DAEMON_FILE"
NAME="$DAEMON_NAME"
PIDFILE="$SERVICE_PID_FILE"

start () {
	if [ \$UID -ne 0 ] ; then
		echo "User has insufficient privileges."
		exit 4
	fi
    	#[ -x \$DAEMON ] || exit 5

	echo -n "Starting \$NAME: "
   	daemon \$NAME --pidfile=\$PIDFILE
 	RETVAL=\$?
	echo
	[ \$RETVAL = 0 ]
	return 0
}

stop () {
	if [ \$UID -ne 0 ] ; then
		echo "User has insufficient privileges."
		exit 4
	fi

	# stop daemon
	echo -n \$"Stopping \$NAME: "
	killproc -p \$PIDFILE
	RETVAL=\$?
	echo
	[ \$RETVAL = 0 ]
	return 0
}

restart() {
	stop
	sleep 1
	start	
	return 0
}

case \$1 in
	start)
		start
	;;
	stop)
		stop
	;;
	restart)
		restart
	;;
	status)
		status -p \$PIDFILE \$NAME
		RETVAL=\$?
        ;;
	*)

	echo \$"Usage: \$NAME {start|stop|restart|status}" 
	exit 2
esac

exit \$RETVAL
__END__
}

Uninstall()
{
    if [ -f $SERVICE_FILE ]; then
        echo "Removing file that was automatically created by the system."
        rm -f $SERVICE_FILE
    fi
}

Register()
{
    echo "Adding automatic loading of $SERVICE_NAME into the system."

    if [ "$2" = "Ubuntu" ]; then
        if which update-rc.d >/dev/null 2>&1; then
	        update-rc.d -f $1 defaults 
        fi
    elif [ "$2" = "RH" ]; then
        if which chkconfig >/dev/null 2>&1; then
        	chkconfig --add $1 
            chkconfig --level 2345 $1 on
        fi
    fi 
}

Unregister()
{
    RESULT=`pgrep $1`
    if [ ! -z "$RESULT" ]; then
        echo "$1 is running. Stopping the service..."
        service $1 stop
    fi

    if [ "$2" = "Ubuntu" ]; then
        if which update-rc.d >/dev/null 2>&1; then
            echo "Removing automatic loading of $1 from the system."
            update-rc.d -f $1 remove 1> /dev/null
        fi
    elif [ "$2" = "RH" ]; then
        if which chkconfig >/dev/null 2>&1; then
	        RESULT=`chkconfig --list | grep $1`
    	    if [ ! -z "$RESULT" ]; then
                echo "Removing automatic loading of $1 from the system."
        	    chkconfig --del $1
            fi
        fi
    fi 
}

ASK="yes"
INSTALL="manual"
UNINSTALL="no"
DISTRIBUTION="Unknown"

# Parse the input arguments
for i in $*
do
    case $i in        
        --install=*)
            INSTALL=${i#*=} 
            ASK="no"
            ;; 
        --uninstall)
            UNINSTALL="yes" 
            ASK="no"
            ;;   	
        --help)
            DisplayHelp
            exit 0
        ;;
        *)
        # unknown option
        DisplayHelp
        exit 1
        ;;
    esac
done

#if no argument, we will ask the user
if [ "$ASK" = "yes" ]; then
    echo ""
    echo "This script allows the management of the $SERVICE_NAME daemon."
    echo "The $SERVICE_NAME daemon is used to manage licenses that are "
    echo "required to use a device that is not enabled by Pleora's technology, "
	echo "and is also used to manage background "
    echo "activities when using USB3 Vision devices."
    echo ""
    echo "The following operations can be performed by this script:"
    echo ""
    echo "0 - Install the daemon to be managed manually."
    echo "1 - Install the daemon and automatically load at boot time."
    echo "2 - Uninstall the daemon."
    echo ""
    ANSWER="not set"
    until [ "$ANSWER" = "0" -o "$ANSWER" = "1" -o "$ANSWER" = "2" ]; do
        echo -n "Enter your selection [0|1|2]. Default is 0. "
        read ANSWER
        if [ -z "$ANSWER" ]; then
            ANSWER="0"
        fi
    done

    # Convert the selection into usable variables
    if [ "$ANSWER" = "0" ]; then
        INSTALL="manual"
        UNINSTALL="no"
    elif [ "$ANSWER" = "1" ]; then
        INSTALL="auto"    
        UNINSTALL="no"
    elif [ "$ANSWER" = "2" ]; then
        INSTALL="skip"    
        UNINSTALL="yes"
    fi
fi

# Validate the entry
if [ "$UNINSTALL" = "yes" ]; then
    echo ""
    echo "Uninstalling the daemon"
    echo ""
    INSTALL="skip"
else
    if [ "$INSTALL" = "manual" ]; then
        echo ""
        echo "Installing the daemon in manual mode."
        echo ""
    elif [ "$INSTALL" = "auto" ]; then
        echo ""
        echo "Installing the daemon in automatic mode."
        echo ""
        if [ ! which update-rc.d >/dev/null 2>&1 ]; then
            echo ""
            echo "WARNING: Cannot install the daemon in automatic mode because the "
            echo " update-rc.d application is not present in this distribution."
            echo " Installation will be done in manual mode. If you want the "
            echo " daemon to start automatically, you must configure it to do so."
			echo "" 
            INSTALL="manual"
        fi
    else
        echo ""
        echo "Unknown installation mode."
        echo ""
        ASK = "yes" 
    fi
fi

if [ "$INSTALL" != "no" ]; then

    DISTRIBUTION="not set"
    if [ -f /etc/redhat-release ]; then   
        if [ -f /etc/rc.d/init.d/functions ]; then
            DISTRIBUTION="RH"
        fi
    elif [ -f /etc/lsb-release ]; then
        if [ -f /lib/lsb/init-functions ]; then
            DISTRIBUTION=`grep DISTRIB_ID /etc/lsb-release | sed -e 's/DISTRIB_ID=//'`
        fi
    fi

    if [ "$DISTRIBUTION" != "Ubuntu" ]; then
        if [ "$DISTRIBUTION" != "RH" ]; then
            echo ""
            echo "Unsupported distribution. Cannot generate the file format."
            echo ""
            exit 3
        fi
    fi
fi

# Check required priviledge
if [ "$USER_ID" != "0" ]; then
  echo "You need to run this script as superuser (root account)."
  exit 1
fi

# Now perform the actions...

# Always uninstall the stuff if we can to present weird states...
Unregister $SERVICE_NAME $DISTRIBUTION
Uninstall $SERVICE_NAME $SERVICE_LINK

# The system is clean, now we can try to install if we have to do it!
if [ "$INSTALL" != "skip" ]; then
    echo ""
    Install $DISTRIBUTION
    if [ "$INSTALL" = "auto" ]; then    
        Register $SERVICE_NAME $DISTRIBUTION
        echo ""
        echo "The daemon will automatically start at load time"
        service $SERVICE_NAME start
    else
        echo ""
        echo "The daemon can now be managed manually."
        echo ""
        echo " Example: "
        echo "    Start the daemon with the following command:"
        echo "         service $SERVICE_NAME start"
        echo "    Stop the daemon with the following command:"
        echo "         service $SERVICE_NAME stop"
        echo "    Query the status of the daemon with the following command:"
        echo "         service $SERVICE_NAME status"
    fi

    # Add rule for Pleora U3V devices all the time if udev available
    if [ -d "/etc/udev/rules.d" ]; then
        echo ""
        echo "Automatically adding rules for Pleora USB3 Vision devices..."
        pushd $SDK_BIN_DIR >> /dev/null
        ./set_udev_rules.sh --add_pleora
        popd >> /dev/null
    fi

    # Check the kernel version for limitation in RH
    if [ "$DISTRIBUTION" = "Ubuntu" ]; then
        NUMBER_VERSION=`uname -r | awk -F. '{ printf("%d\n", ( $1 * 1000000 ) + ( $2 * 1000 ) + ( $3 ) ); }'`
        if [ "$NUMBER_VERSION" -lt "3002000" ]; then
            echo ""
            echo "WARNING : The 3.2 Linux kernel is required to use USB 3.0 devices."
            echo "          To ensure correct operation, USB 3.0 controllers will not enumerate the USB3 Vision devices."
        fi
    elif [ "$DISTRIBUTION" = "RH" ]; then
        NUMBER_VERSION=`uname -r | awk -F"[.-]" '{ printf("%d\n", ( $1 * 10000000000 ) + ( $2 * 10000000 ) + ( $3 * 10000 ) + ( $4 ) ); }'`
        if [ "$NUMBER_VERSION" -lt "20060320431" ]; then
            echo ""
            echo "WARNING : The 2.6.32-431 Linux kernel is required to use USB 3.0 devices."
            echo "          To ensure correct operation, USB 3.0 controllers will not enumerate the USB3 Vision devices."
        fi
    fi 

else
    pushd $SDK_BIN_DIR >> /dev/null
    ./set_udev_rules.sh --remove_pleora
    popd >> /dev/null
fi

echo ""


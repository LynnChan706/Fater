<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
		<title>PvTransmitterGEV Class Reference</title>
		<link href="doxygen.css" rel="stylesheet" type="text/css">
		<link href="tabs.css" rel="stylesheet" type="text/css">
	</head>
	<body>
	<div class="contents">
		<div class="textblock">
			<h2><a href="http://www.pleora.com" target="_blank"><img src="logo.jpg" alt="Pleora Technologies Inc." align="middle" border="0"></a>
			eBUS SDK v4.1.4.3606 API</h2>
		</div>
	</div>
	<br>
	<br>
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_pv_transmitter_g_e_v.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_pv_transmitter_g_e_v-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PvTransmitterGEV Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class for transmitting blocks using the GigE Vision streaming protocol.  
 <a href="class_pv_transmitter_g_e_v.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a69c8cf9d29815558782c3b9cebad93f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69c8cf9d29815558782c3b9cebad93f1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#a69c8cf9d29815558782c3b9cebad93f1">PvTransmitterGEV</a> ()</td></tr>
<tr class="memdesc:a69c8cf9d29815558782c3b9cebad93f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br/></td></tr>
<tr class="separator:a69c8cf9d29815558782c3b9cebad93f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b07ea9a0141aa28fdee17c0d3fb6875"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b07ea9a0141aa28fdee17c0d3fb6875"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#a4b07ea9a0141aa28fdee17c0d3fb6875">~PvTransmitterGEV</a> ()</td></tr>
<tr class="memdesc:a4b07ea9a0141aa28fdee17c0d3fb6875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="separator:a4b07ea9a0141aa28fdee17c0d3fb6875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6547a5f74c7b579ace3835fdf5904e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#aec6547a5f74c7b579ace3835fdf5904e">Open</a> (<a class="el" href="class_pv_string.html">PvString</a> aDestinationIPAddress, uint16_t aDestinationPort, <a class="el" href="class_pv_string.html">PvString</a> aSourceIPAddress=&quot;&quot;, uint16_t aSourcePort=0, bool aDontFrag=true, bool aExtendedID=false, uint32_t aBuffersCapacity=64, bool aTimestampWhenSending=false)</td></tr>
<tr class="memdesc:aec6547a5f74c7b579ace3835fdf5904e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a socket to begin transmitting data.  <a href="#aec6547a5f74c7b579ace3835fdf5904e">More...</a><br/></td></tr>
<tr class="separator:aec6547a5f74c7b579ace3835fdf5904e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44cccdb8b355d061ad99b64f888cb14a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#a44cccdb8b355d061ad99b64f888cb14a">Close</a> ()</td></tr>
<tr class="memdesc:a44cccdb8b355d061ad99b64f888cb14a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop sending data and close the socket.  <a href="#a44cccdb8b355d061ad99b64f888cb14a">More...</a><br/></td></tr>
<tr class="separator:a44cccdb8b355d061ad99b64f888cb14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde820b824057efc1318642a513ae7c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#adde820b824057efc1318642a513ae7c4">IsOpen</a> () const </td></tr>
<tr class="memdesc:adde820b824057efc1318642a513ae7c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a connection is available to begin transmitting blocks.  <a href="#adde820b824057efc1318642a513ae7c4">More...</a><br/></td></tr>
<tr class="separator:adde820b824057efc1318642a513ae7c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3e2d6577a798686398a37dbe1afd7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#a2c3e2d6577a798686398a37dbe1afd7d">LoadBufferPool</a> (<a class="el" href="class_pv_buffer.html">PvBuffer</a> **aBuffers, uint32_t aBufferCount)</td></tr>
<tr class="memdesc:a2c3e2d6577a798686398a37dbe1afd7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a set of free buffers into the pool.  <a href="#a2c3e2d6577a798686398a37dbe1afd7d">More...</a><br/></td></tr>
<tr class="separator:a2c3e2d6577a798686398a37dbe1afd7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68d66dcaad6bb4a5ac93a60f890b5f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#ac68d66dcaad6bb4a5ac93a60f890b5f2">QueueBuffer</a> (<a class="el" href="class_pv_buffer.html">PvBuffer</a> *aBuffer)</td></tr>
<tr class="memdesc:ac68d66dcaad6bb4a5ac93a60f890b5f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue one buffer in to be transmitted when a connection is available.  <a href="#ac68d66dcaad6bb4a5ac93a60f890b5f2">More...</a><br/></td></tr>
<tr class="separator:ac68d66dcaad6bb4a5ac93a60f890b5f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819b018308bd20fcb6f54401d0b73e85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#a819b018308bd20fcb6f54401d0b73e85">RetrieveFreeBuffer</a> (<a class="el" href="class_pv_buffer.html">PvBuffer</a> **aBuffer, uint32_t aTimeout=0xFFFFFFFF)</td></tr>
<tr class="memdesc:a819b018308bd20fcb6f54401d0b73e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a free buffer from the list of available buffers.  <a href="#a819b018308bd20fcb6f54401d0b73e85">More...</a><br/></td></tr>
<tr class="separator:a819b018308bd20fcb6f54401d0b73e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd57f4bede1eb7ecbb232dd63d35eed0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#abd57f4bede1eb7ecbb232dd63d35eed0">AbortQueuedBuffers</a> (uint32_t aTimeout=0xFFFFFFFF, bool *aPartialTransmission=NULL)</td></tr>
<tr class="memdesc:abd57f4bede1eb7ecbb232dd63d35eed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees all pending transmission requests.  <a href="#abd57f4bede1eb7ecbb232dd63d35eed0">More...</a><br/></td></tr>
<tr class="separator:abd57f4bede1eb7ecbb232dd63d35eed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac632a30e4791ae59488b409a81cb8404"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#ac632a30e4791ae59488b409a81cb8404">GetQueuedBufferCount</a> ()</td></tr>
<tr class="memdesc:ac632a30e4791ae59488b409a81cb8404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of buffers queued for transmission including the ones that are currently being sent.  <a href="#ac632a30e4791ae59488b409a81cb8404">More...</a><br/></td></tr>
<tr class="separator:ac632a30e4791ae59488b409a81cb8404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e3c708dd3aedb9cd8404c7f7e853337"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#a3e3c708dd3aedb9cd8404c7f7e853337">GetPacketSize</a> ()</td></tr>
<tr class="memdesc:a3e3c708dd3aedb9cd8404c7f7e853337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum packet size of GVSP payload packets.  <a href="#a3e3c708dd3aedb9cd8404c7f7e853337">More...</a><br/></td></tr>
<tr class="separator:a3e3c708dd3aedb9cd8404c7f7e853337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13cc530ca94ed0f4e39f3f32fa9bc0c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#a13cc530ca94ed0f4e39f3f32fa9bc0c8">SetPacketSize</a> (uint32_t aPacketSize)</td></tr>
<tr class="memdesc:a13cc530ca94ed0f4e39f3f32fa9bc0c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum packet size of GVSP payload packets.  <a href="#a13cc530ca94ed0f4e39f3f32fa9bc0c8">More...</a><br/></td></tr>
<tr class="separator:a13cc530ca94ed0f4e39f3f32fa9bc0c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054102efd21e59e496c1cc222324295f"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#a054102efd21e59e496c1cc222324295f">GetMaxPayloadThroughput</a> ()</td></tr>
<tr class="memdesc:a054102efd21e59e496c1cc222324295f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum effective throughput in bps.  <a href="#a054102efd21e59e496c1cc222324295f">More...</a><br/></td></tr>
<tr class="separator:a054102efd21e59e496c1cc222324295f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6bdd7683f25dd7e8823729bc020b69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#a5b6bdd7683f25dd7e8823729bc020b69">SetMaxPayloadThroughput</a> (float aMaxPayloadThroughput)</td></tr>
<tr class="memdesc:a5b6bdd7683f25dd7e8823729bc020b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the desired effective throughput in bps.  <a href="#a5b6bdd7683f25dd7e8823729bc020b69">More...</a><br/></td></tr>
<tr class="separator:a5b6bdd7683f25dd7e8823729bc020b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0696be49de252856b0476d39eae6c61"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#ac0696be49de252856b0476d39eae6c61">GetSourcePort</a> ()</td></tr>
<tr class="memdesc:ac0696be49de252856b0476d39eae6c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the port from which blocks are transmitted.  <a href="#ac0696be49de252856b0476d39eae6c61">More...</a><br/></td></tr>
<tr class="separator:ac0696be49de252856b0476d39eae6c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58fcf632bdc8537ccbecdbf202cd9722"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#a58fcf632bdc8537ccbecdbf202cd9722">GetDestinationPort</a> ()</td></tr>
<tr class="memdesc:a58fcf632bdc8537ccbecdbf202cd9722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the port to which blocks are transmitted.  <a href="#a58fcf632bdc8537ccbecdbf202cd9722">More...</a><br/></td></tr>
<tr class="separator:a58fcf632bdc8537ccbecdbf202cd9722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd11686f94146a6398d33290dd45c7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_string.html">PvString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#a7bd11686f94146a6398d33290dd45c7e">GetDestinationIPAddress</a> ()</td></tr>
<tr class="memdesc:a7bd11686f94146a6398d33290dd45c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the IP address to which blocks are transmitted.  <a href="#a7bd11686f94146a6398d33290dd45c7e">More...</a><br/></td></tr>
<tr class="separator:a7bd11686f94146a6398d33290dd45c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f28172042dc0ae9143f8779b2b07255"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_string.html">PvString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#a2f28172042dc0ae9143f8779b2b07255">GetSourceIPAddress</a> ()</td></tr>
<tr class="memdesc:a2f28172042dc0ae9143f8779b2b07255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the IP address from which blocks are transmitted.  <a href="#a2f28172042dc0ae9143f8779b2b07255">More...</a><br/></td></tr>
<tr class="separator:a2f28172042dc0ae9143f8779b2b07255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318aab879c5c23bf773f99d593c345e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a318aab879c5c23bf773f99d593c345e8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#a318aab879c5c23bf773f99d593c345e8">ResetStats</a> ()</td></tr>
<tr class="memdesc:a318aab879c5c23bf773f99d593c345e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero all running counters. <br/></td></tr>
<tr class="separator:a318aab879c5c23bf773f99d593c345e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e7f9a667370e21554611bd4af11d53a"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#a5e7f9a667370e21554611bd4af11d53a">GetBlocksTransmitted</a> () const </td></tr>
<tr class="memdesc:a5e7f9a667370e21554611bd4af11d53a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of blocks transmitted.  <a href="#a5e7f9a667370e21554611bd4af11d53a">More...</a><br/></td></tr>
<tr class="separator:a5e7f9a667370e21554611bd4af11d53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad274e981512bd124e7c1c42d8316d82c"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#ad274e981512bd124e7c1c42d8316d82c">GetSamplingTime</a> () const </td></tr>
<tr class="memdesc:ad274e981512bd124e7c1c42d8316d82c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the time since last reset.  <a href="#ad274e981512bd124e7c1c42d8316d82c">More...</a><br/></td></tr>
<tr class="separator:ad274e981512bd124e7c1c42d8316d82c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9294317f3681a89c11e33d761c5723e9"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#a9294317f3681a89c11e33d761c5723e9">GetPayloadBytesTransmitted</a> () const </td></tr>
<tr class="memdesc:a9294317f3681a89c11e33d761c5723e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of payload bytes transmitted.  <a href="#a9294317f3681a89c11e33d761c5723e9">More...</a><br/></td></tr>
<tr class="separator:a9294317f3681a89c11e33d761c5723e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f710d57497544699c22001c501a2570"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#a4f710d57497544699c22001c501a2570">GetInstantaneousPayloadThroughput</a> () const </td></tr>
<tr class="memdesc:a4f710d57497544699c22001c501a2570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an instantaneous calculation of the payload throughput (in bps).  <a href="#a4f710d57497544699c22001c501a2570">More...</a><br/></td></tr>
<tr class="separator:a4f710d57497544699c22001c501a2570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae54c1db3786711006eec4418c97e9475"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#ae54c1db3786711006eec4418c97e9475">GetAveragePayloadThroughput</a> () const </td></tr>
<tr class="memdesc:ae54c1db3786711006eec4418c97e9475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the average payload throughput (in bps).  <a href="#ae54c1db3786711006eec4418c97e9475">More...</a><br/></td></tr>
<tr class="separator:ae54c1db3786711006eec4418c97e9475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62cc7d00af9001ef63fe3d2aaf5fb6f"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#af62cc7d00af9001ef63fe3d2aaf5fb6f">GetInstantaneousTransmissionRate</a> () const </td></tr>
<tr class="memdesc:af62cc7d00af9001ef63fe3d2aaf5fb6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the instantaneous transmission rate (in blocks/second).  <a href="#af62cc7d00af9001ef63fe3d2aaf5fb6f">More...</a><br/></td></tr>
<tr class="separator:af62cc7d00af9001ef63fe3d2aaf5fb6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e273cc7351f65b27b148e34e497cf4"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#ab0e273cc7351f65b27b148e34e497cf4">GetAverageTransmissionRate</a> () const </td></tr>
<tr class="memdesc:ab0e273cc7351f65b27b148e34e497cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the average transmission rate (in blocks/second).  <a href="#ab0e273cc7351f65b27b148e34e497cf4">More...</a><br/></td></tr>
<tr class="separator:ab0e273cc7351f65b27b148e34e497cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b1950fa1d170a24d862aa69d7fbf99"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#ab0b1950fa1d170a24d862aa69d7fbf99">GetUserModeTransmitterThreadPriority</a> () const </td></tr>
<tr class="memdesc:ab0b1950fa1d170a24d862aa69d7fbf99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the priority of the thread in charge of sending the packets on the network.  <a href="#ab0b1950fa1d170a24d862aa69d7fbf99">More...</a><br/></td></tr>
<tr class="separator:ab0b1950fa1d170a24d862aa69d7fbf99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8ae686fb754a415e3a6d8ea92afeb4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#ad8ae686fb754a415e3a6d8ea92afeb4d">SetUserModeTransmitterThreadPriority</a> (uint32_t aPriority)</td></tr>
<tr class="memdesc:ad8ae686fb754a415e3a6d8ea92afeb4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the priority of the thread in charge of sending the packets on the network.  <a href="#ad8ae686fb754a415e3a6d8ea92afeb4d">More...</a><br/></td></tr>
<tr class="separator:ad8ae686fb754a415e3a6d8ea92afeb4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ad7f9854a305b96734bd9335e49365"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#a12ad7f9854a305b96734bd9335e49365">GetBufferPoolThreadPriority</a> () const </td></tr>
<tr class="memdesc:a12ad7f9854a305b96734bd9335e49365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the priority of the thread used to manage the buffer of the buffer pool.  <a href="#a12ad7f9854a305b96734bd9335e49365">More...</a><br/></td></tr>
<tr class="separator:a12ad7f9854a305b96734bd9335e49365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7e0170148bec8c62c2f685997e2cc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_transmitter_g_e_v.html#a1d7e0170148bec8c62c2f685997e2cc2">SetBufferPoolThreadPriority</a> (uint32_t aPriority)</td></tr>
<tr class="memdesc:a1d7e0170148bec8c62c2f685997e2cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the priority of the thread used to manage the buffer of the buffer pool.  <a href="#a1d7e0170148bec8c62c2f685997e2cc2">More...</a><br/></td></tr>
<tr class="separator:a1d7e0170148bec8c62c2f685997e2cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class for transmitting blocks using the GigE Vision streaming protocol. </p>
<p><b>Procedure for transmitting blocks (images or raw data) with the eBUS SDK:</b></p>
<ul>
<li>Ensure that the transmitter knows where to send blocks by calling <a class="el" href="class_pv_transmitter_g_e_v.html#aec6547a5f74c7b579ace3835fdf5904e" title="Initialize a socket to begin transmitting data. ">Open</a>.</li>
<li>Initialize the transmitter with a set of free buffers (<a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> objects) by calling <a class="el" href="class_pv_transmitter_g_e_v.html#a2c3e2d6577a798686398a37dbe1afd7d" title="Load a set of free buffers into the pool. ">LoadBufferPool</a>.</li>
<li>Retrieve a free buffer to populate by calling <a class="el" href="class_pv_transmitter_g_e_v.html#a819b018308bd20fcb6f54401d0b73e85" title="Retrieve a free buffer from the list of available buffers. ">RetrieveFreeBuffer</a>.</li>
<li>Queue a buffer for transmission by calling <a class="el" href="class_pv_transmitter_g_e_v.html#ac68d66dcaad6bb4a5ac93a60f890b5f2" title="Queue one buffer in to be transmitted when a connection is available. ">QueueBuffer</a>.</li>
<li>Once a buffer has been transmitted, it can be retrieved again by calling <a class="el" href="class_pv_transmitter_g_e_v.html#a819b018308bd20fcb6f54401d0b73e85" title="Retrieve a free buffer from the list of available buffers. ">RetrieveFreeBuffer</a>.</li>
</ul>
<p>The status of a given <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> object can be retrieved by calling <a class="el" href="class_pv_buffer.html#ab6089cf8573309e856216d0700beecca" title="Returns the value of aOperationResult when this buffer was last received through a PvStream...">PvBuffer::GetOperationResult</a>.</p>
<ul>
<li>An operation result of <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> indicates that the buffer was transmitted successfully.</li>
<li>An operation result of <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca5709b0ee04f203c1b36965dab780d2e6">PvResult::Code::NETWORK_ERROR</a> indicates that there was a problem transmitting the buffer (likely due to a lack of connectivity).</li>
<li>An operation result of <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca02e7e13232d736f9215df059aa92280f">PvResult::Code::ABORTED</a> indicates that the transmission of that buffer was aborted (typically by calling <a class="el" href="class_pv_transmitter_g_e_v.html#abd57f4bede1eb7ecbb232dd63d35eed0" title="Frees all pending transmission requests. ">AbortQueuedBuffers</a>).</li>
<li>An operation result of <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca243bf1f15a65a48672b6a2916359951a">PvResult::Code::PENDING</a> indicates that the buffer has not yet been fully transmitted.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="class_pv_transmitter_g_e_v.html" title="Class for transmitting blocks using the GigE Vision streaming protocol. ">PvTransmitterGEV</a> is only responsible for transmitting blocks. It does not implement a control channel like a complete GigE Vision device. To receive transmitted blocks with a <a class="el" href="class_pv_stream.html" title="Receive data from a GigE Vision or USB3 Vision transmitter. ">PvStream</a> application (such as eBUS Player), the transmitting application must be set up to respond to device discovery requests. Use <a class="el" href="class_pv_virtual_device_g_e_v.html" title="Virtual GigE Vision device. ">PvVirtualDeviceGEV</a> to respond to device discovery requests. If using eBUS Player or NetCommand to receive data being transmitted with this class, ensure that the application is set up as <b>Data Receiver Only</b>.</dd></dl>
<p>For an illustration of how this API is used in practice, refer to the following source code samples in the samples directory where the eBUS SDK resides:</p>
<ul>
<li>TransmitTestPattern - Transmits a test pattern to a given destination. This is the easiest starting point for learning to use <a class="el" href="class_pv_transmitter_g_e_v.html" title="Class for transmitting blocks using the GigE Vision streaming protocol. ">PvTransmitterGEV</a>.</li>
<li>TransmitProcessImage - Receives video from a GigE Vision device using <a class="el" href="class_pv_stream.html" title="Receive data from a GigE Vision or USB3 Vision transmitter. ">PvStream</a> and <a class="el" href="class_pv_pipeline.html" title="Helper class for receiving data from a GigE Vision or USB3 Vision transmitter. ">PvPipeline</a>, re-samples it and print text on it using OpenCV and finally transmits it using <a class="el" href="class_pv_transmitter_g_e_v.html" title="Class for transmitting blocks using the GigE Vision streaming protocol. ">PvTransmitterGEV</a>.</li>
<li>TransmitTiledImagesSample - An MFC GUI application that receives video from multiple GEV transmitters, tiles into one video feed and transmits to a given destination. </li>
</ul>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="abd57f4bede1eb7ecbb232dd63d35eed0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvTransmitterGEV::AbortQueuedBuffers </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aTimeout</em> = <code>0xFFFFFFFF</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>aPartialTransmission</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees all pending transmission requests. </p>
<p>Buffers that were aborted will have an operation result set at <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca02e7e13232d736f9215df059aa92280f">PvResult::Code::ABORTED</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aTimeout</td><td>Represents the maximum number of milliseconds to wait for the current transmit operation before returning <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca8044711331afcc8f9607defdeb4f897f">PvResult::Code::TIMEOUT</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aPartialTransmission</td><td>Output, set to true if transmission was stopped in the middle of a block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> if successful </dd></dl>

</div>
</div>
<a class="anchor" id="a44cccdb8b355d061ad99b64f888cb14a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvTransmitterGEV::Close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop sending data and close the socket. </p>
<p>Any buffers that are in the middle of being transmitted are aborted.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> if successful </dd></dl>

</div>
</div>
<a class="anchor" id="ae54c1db3786711006eec4418c97e9475"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float PvTransmitterGEV::GetAveragePayloadThroughput </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the average payload throughput (in bps). </p>
<p>Average payload transmission rate is equivalent to <a class="el" href="class_pv_transmitter_g_e_v.html#a9294317f3681a89c11e33d761c5723e9" title="Get the number of payload bytes transmitted. ">GetPayloadBytesTransmitted()</a> * 8 / <a class="el" href="class_pv_transmitter_g_e_v.html#ad274e981512bd124e7c1c42d8316d82c" title="Get the time since last reset. ">GetSamplingTime()</a>. Note that this calculation only includes the number of useful data bytes and does not include GVSP, IP and UDP header overhead.</p>
<dl class="section return"><dt>Returns</dt><dd>The average network throughput (in bps) </dd></dl>

</div>
</div>
<a class="anchor" id="ab0e273cc7351f65b27b148e34e497cf4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float PvTransmitterGEV::GetAverageTransmissionRate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the average transmission rate (in blocks/second). </p>
<p>Average transmission rate is equivalent to <a class="el" href="class_pv_transmitter_g_e_v.html#a5e7f9a667370e21554611bd4af11d53a" title="Get the number of blocks transmitted. ">GetBlocksTransmitted()</a> / <a class="el" href="class_pv_transmitter_g_e_v.html#ad274e981512bd124e7c1c42d8316d82c" title="Get the time since last reset. ">GetSamplingTime()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>The average transmission rate (in blocks/second) </dd></dl>

</div>
</div>
<a class="anchor" id="a5e7f9a667370e21554611bd4af11d53a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t PvTransmitterGEV::GetBlocksTransmitted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of blocks transmitted. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of blocks this object has transmitted. </dd></dl>

</div>
</div>
<a class="anchor" id="a12ad7f9854a305b96734bd9335e49365"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvTransmitterGEV::GetBufferPoolThreadPriority </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the priority of the thread used to manage the buffer of the buffer pool. </p>
<p>See <a class="el" href="class_pv_transmitter_g_e_v.html#a1d7e0170148bec8c62c2f685997e2cc2" title="Set the priority of the thread used to manage the buffer of the buffer pool. ">SetBufferPoolThreadPriority</a> for details about the meaning of the values returned</p>
<dl class="section return"><dt>Returns</dt><dd>The priority of the thread </dd></dl>

</div>
</div>
<a class="anchor" id="a7bd11686f94146a6398d33290dd45c7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_string.html">PvString</a> PvTransmitterGEV::GetDestinationIPAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the IP address to which blocks are transmitted. </p>
<dl class="section return"><dt>Returns</dt><dd>The ip address to which blocks are transmitted. Returns an empty string when a connection has not yet been opened. </dd></dl>

</div>
</div>
<a class="anchor" id="a58fcf632bdc8537ccbecdbf202cd9722"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t PvTransmitterGEV::GetDestinationPort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the port to which blocks are transmitted. </p>
<dl class="section return"><dt>Returns</dt><dd>The port number to which blocks are transmitted. Returns 0 when a connection has not yet been opened. </dd></dl>

</div>
</div>
<a class="anchor" id="a4f710d57497544699c22001c501a2570"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float PvTransmitterGEV::GetInstantaneousPayloadThroughput </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an instantaneous calculation of the payload throughput (in bps). </p>
<p>Instantaneous payload transmission rate is measured using a short time frame. Note that this calculation only includes the number of useful data bytes and does not include GVSP, IP and UDP header overhead.</p>
<dl class="section return"><dt>Returns</dt><dd>The payload transmission rate (in bps) </dd></dl>

</div>
</div>
<a class="anchor" id="af62cc7d00af9001ef63fe3d2aaf5fb6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float PvTransmitterGEV::GetInstantaneousTransmissionRate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the instantaneous transmission rate (in blocks/second). </p>
<p>Instantaneous transmission rate is measured using a short time frame.</p>
<dl class="section return"><dt>Returns</dt><dd>The instantaneous transmission rate (in blocks/second) </dd></dl>

</div>
</div>
<a class="anchor" id="a054102efd21e59e496c1cc222324295f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float PvTransmitterGEV::GetMaxPayloadThroughput </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum effective throughput in bps. </p>
<p>An occasional delay is placed between the packets being transmitted to attempt to throttle the effective throughput. This helps to spread out network traffic to optimize bandwidth availability for other applications. A value of 0 (default) indicates that there should be no throttling based on throughput.</p>
<dl class="section return"><dt>Returns</dt><dd>the desired throughput in bps. </dd></dl>

</div>
</div>
<a class="anchor" id="a3e3c708dd3aedb9cd8404c7f7e853337"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvTransmitterGEV::GetPacketSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum packet size of GVSP payload packets. </p>
<p>When a block is packetized and transmitted, the payload is broken down into packets of a given size. The default value for the maximum packet size is 1440 because that is the size that should work in theory for all network adapters.</p>
<p>For best results, enable jumbo packets in your network adapter properties and increase the maximum packet size to match When sending very small blocks at high frame rates it may sometimes be desirable to set the maximum packet size to a lower number.</p>
<dl class="section return"><dt>Returns</dt><dd>The maximum packet size (in bytes). </dd></dl>

</div>
</div>
<a class="anchor" id="a9294317f3681a89c11e33d761c5723e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t PvTransmitterGEV::GetPayloadBytesTransmitted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of payload bytes transmitted. </p>
<p>Note that this value only includes the number of useful data bytes and does not include GVSP, IP and UDP header overhead.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of payload bytes transmitted. </dd></dl>

</div>
</div>
<a class="anchor" id="ac632a30e4791ae59488b409a81cb8404"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvTransmitterGEV::GetQueuedBufferCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of buffers queued for transmission including the ones that are currently being sent. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of buffers queued for transmission including the ones that are currently being sent. </dd></dl>

</div>
</div>
<a class="anchor" id="ad274e981512bd124e7c1c42d8316d82c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t PvTransmitterGEV::GetSamplingTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the time since last reset. </p>
<dl class="section return"><dt>Returns</dt><dd>The time, in ms, since the counters were zeroed; the time since the object was created, the transmitter was opened (using <a class="el" href="class_pv_transmitter_g_e_v.html#aec6547a5f74c7b579ace3835fdf5904e" title="Initialize a socket to begin transmitting data. ">Open</a>), or <a class="el" href="class_pv_transmitter_g_e_v.html#a318aab879c5c23bf773f99d593c345e8" title="Zero all running counters. ">ResetStats</a> was called. </dd></dl>

</div>
</div>
<a class="anchor" id="a2f28172042dc0ae9143f8779b2b07255"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_string.html">PvString</a> PvTransmitterGEV::GetSourceIPAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the IP address from which blocks are transmitted. </p>
<dl class="section return"><dt>Returns</dt><dd>The IP address from which blocks are transmitted. Returns an empty string when a connection has not yet been opened. </dd></dl>

</div>
</div>
<a class="anchor" id="ac0696be49de252856b0476d39eae6c61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t PvTransmitterGEV::GetSourcePort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the port from which blocks are transmitted. </p>
<dl class="section return"><dt>Returns</dt><dd>The port number from which blocks are transmitted. Returns 0 when a connection has not yet been opened. </dd></dl>

</div>
</div>
<a class="anchor" id="ab0b1950fa1d170a24d862aa69d7fbf99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvTransmitterGEV::GetUserModeTransmitterThreadPriority </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the priority of the thread in charge of sending the packets on the network. </p>
<p>See <a class="el" href="class_pv_transmitter_g_e_v.html#ad8ae686fb754a415e3a6d8ea92afeb4d" title="Set the priority of the thread in charge of sending the packets on the network. ">SetUserModeTransmitterThreadPriority</a> for details about the meaning of the values returned</p>
<dl class="section return"><dt>Returns</dt><dd>The priority of the thread </dd></dl>

</div>
</div>
<a class="anchor" id="adde820b824057efc1318642a513ae7c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PvTransmitterGEV::IsOpen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether a connection is available to begin transmitting blocks. </p>
<p>Call <a class="el" href="class_pv_transmitter_g_e_v.html#aec6547a5f74c7b579ace3835fdf5904e" title="Initialize a socket to begin transmitting data. ">Open</a> to ensure that the tranmitter knows where to begin transmitting blocks.</p>
<dl class="section return"><dt>Returns</dt><dd>True if a connection is available. False if no connection is available. </dd></dl>

</div>
</div>
<a class="anchor" id="a2c3e2d6577a798686398a37dbe1afd7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvTransmitterGEV::LoadBufferPool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pv_buffer.html">PvBuffer</a> **&#160;</td>
          <td class="paramname"><em>aBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aBufferCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a set of free buffers into the pool. </p>
<p>This method provides the transmitter with a set of free buffers that can be retrieved immediately by calling <a class="el" href="class_pv_transmitter_g_e_v.html#a819b018308bd20fcb6f54401d0b73e85" title="Retrieve a free buffer from the list of available buffers. ">RetrieveFreeBuffer</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aBuffers</td><td>An array of pointers to <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> objects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aBufferCount</td><td>The number of buffer pointers provided.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> if successful </dd></dl>

</div>
</div>
<a class="anchor" id="aec6547a5f74c7b579ace3835fdf5904e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvTransmitterGEV::Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pv_string.html">PvString</a>&#160;</td>
          <td class="paramname"><em>aDestinationIp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>aDestinationPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pv_string.html">PvString</a>&#160;</td>
          <td class="paramname"><em>aSourceIp</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>aSourcePort</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>aDontFrag</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>aExtendedID</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aBuffersCapacity</em> = <code>64</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>aTimestampWhenSending</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a socket to begin transmitting data. </p>
<p>Once this call is completed successfully, the transmitter will begin sending blocks as soon as the first buffer is queued in by calling <a class="el" href="class_pv_transmitter_g_e_v.html#ac68d66dcaad6bb4a5ac93a60f890b5f2" title="Queue one buffer in to be transmitted when a connection is available. ">QueueBuffer</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aDestinationIp</td><td>The address to which the transmitter will send. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aDestinationPort</td><td>The port to which the transmitter will send. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aSourceIp</td><td>The address from which the transmitter will send. If the parameter is an empty string (default), the socket will not be bound to a specific local IP address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aSourcePort</td><td>The port from which the transmitter will send. If the parameter is 0 (default), the source port will be dynamically assigned by the operating system. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aDontFrag</td><td>The value of the Don't Fragment flag in the IP header. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aExtendedID</td><td>Use the extended id for blocks and packets when set to true. It should only be used with a GEV 2.0 compliant receiver. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aBuffersCapacity</td><td>Maximum number of buffer that can be stored simultaneously in the lower layer of the transmitter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aTimestampWhenSending</td><td>Set the timestamp in the buffer header before sending the packets</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> if successful <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca5709b0ee04f203c1b36965dab780d2e6">PvResult::Code::NETWORK_ERROR</a> if the socket could not be created </dd></dl>

</div>
</div>
<a class="anchor" id="ac68d66dcaad6bb4a5ac93a60f890b5f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvTransmitterGEV::QueueBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pv_buffer.html">PvBuffer</a> *&#160;</td>
          <td class="paramname"><em>aBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queue one buffer in to be transmitted when a connection is available. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aBuffer</td><td>The buffer to transmit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> if successful. <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca37cf2b6eb84b2f3286393bc9108cfab4">PvResult::Code::BUFFER_TOO_SMALL</a> if the buffer is empty. </dd></dl>

</div>
</div>
<a class="anchor" id="a819b018308bd20fcb6f54401d0b73e85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvTransmitterGEV::RetrieveFreeBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pv_buffer.html">PvBuffer</a> **&#160;</td>
          <td class="paramname"><em>aBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aTimeout</em> = <code>0xFFFFFFFF</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a free buffer from the list of available buffers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">aBuffer</td><td>The buffer that is available to populate and transmit. The pointer is set to NULL if no buffer is available. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aTimeout</td><td>The maximum number of milliseconds to wait for a free buffer to become available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> if successful.or <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca8044711331afcc8f9607defdeb4f897f">PvResult::Code::TIMEOUT</a> if the aTimeout parameter was exceeded while waiting for a buffer to become available. </dd></dl>

</div>
</div>
<a class="anchor" id="a1d7e0170148bec8c62c2f685997e2cc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvTransmitterGEV::SetBufferPoolThreadPriority </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aPriority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the priority of the thread used to manage the buffer of the buffer pool. </p>
<p>Only applicable if using a buffer pool ( See <a class="el" href="class_pv_transmitter_g_e_v.html#a2c3e2d6577a798686398a37dbe1afd7d" title="Load a set of free buffers into the pool. ">LoadBufferPool</a> ). The thread will manage the buffer exchange with the transmitter.</p>
<p>If you change the thread priorities, it may alterate the stability of the system. For this reason, if you report a bug to Pleora, ensure to clearly mention that you change threads priorities.</p>
<p>See <a class="el" href="class_pv_transmitter_g_e_v.html#a12ad7f9854a305b96734bd9335e49365" title="Get the priority of the thread used to manage the buffer of the buffer pool. ">GetBufferPoolThreadPriority</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aPriority</td><td>See <a class="el" href="class_pv_pipeline.html#abee6125a1608074ad5a7b141ed58f52c" title="Set the priority of the pipeline thread. ">PvPipeline::SetBufferHandlingThreadPriority</a> for description of the supported values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa01691a7ea2f9fd92fb720c5477bcda1">PvResult::Code::INVALID_PARAMETER</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca75e1d2230eff41caaf8074951249d63c">PvResult::Code::THREAD_ERROR</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a5b6bdd7683f25dd7e8823729bc020b69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvTransmitterGEV::SetMaxPayloadThroughput </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>aMaxPayloadThroughput</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the desired effective throughput in bps. </p>
<p>An occasional delay is placed between the packets being transmitted to attempt to throttle the effective throughput. This helps to spread out network traffic to optimize bandwidth availability for other applications. A value of 0 (default) indicates that there should be no throttling based on throughput.</p>
<p>The throughput is measured in effective throughput on the content of the transmitted <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> objects. It does not take into account the GigE Vision, UDP, IP and Ethernet protocol overhead of the packetized data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aMaxPayloadThroughput</td><td>The maximum throughput in bps.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> if successful. </dd></dl>

</div>
</div>
<a class="anchor" id="a13cc530ca94ed0f4e39f3f32fa9bc0c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvTransmitterGEV::SetPacketSize </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aPacketSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the maximum packet size of GVSP payload packets. </p>
<p>When a block is packetized and transmitted, the payload is broken down into packets of a given size. The default value for the maximum packet size is 1440 because that is the size that should work in theory for all network adapters.</p>
<p>For best results, enable jumbo packets in your network adapter properties and increase the maximum packet size to match When sending very small blocks at high frame rates it may sometimes be desirable to set the maximum packet size to a lower number.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aPacketSize</td><td>The maximum packet size (in bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> if successful, <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa01691a7ea2f9fd92fb720c5477bcda1">PvResult::Code::INVALID_PARAMETER</a> if aPacketSize is less than or equal to 36 </dd></dl>

</div>
</div>
<a class="anchor" id="ad8ae686fb754a415e3a6d8ea92afeb4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvTransmitterGEV::SetUserModeTransmitterThreadPriority </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aPriority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the priority of the thread in charge of sending the packets on the network. </p>
<p>Only applicable if using a user-mode transmitter. The thread priority of a driver-based transmitter cannot be controlled. Thread that is responsible for breaking buffers in packets and transmitting them.</p>
<p>If you change the thread priorities, it may alterate the stability of the system. For this reason, if you report a bug to Pleora, ensure to clearly mention that you change threads priorities.</p>
<p>See <a class="el" href="class_pv_transmitter_g_e_v.html#ab0b1950fa1d170a24d862aa69d7fbf99" title="Get the priority of the thread in charge of sending the packets on the network. ">GetUserModeTransmitterThreadPriority</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aPriority</td><td>See <a class="el" href="class_pv_pipeline.html#abee6125a1608074ad5a7b141ed58f52c" title="Set the priority of the pipeline thread. ">PvPipeline::SetBufferHandlingThreadPriority</a> for description of the supported values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa01691a7ea2f9fd92fb720c5477bcda1">PvResult::Code::INVALID_PARAMETER</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca75e1d2230eff41caaf8074951249d63c">PvResult::Code::THREAD_ERROR</a> </li>
</ul>
</dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_pv_transmitter_g_e_v_8h_source.html">PvTransmitterGEV.h</a></li>
<li>PvTransmitterGEV.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr size="1">
<P><B>Copyright (c) 2002-2015 Pleora Technologies Inc.</B><BR>
<a href="http://www.pleora.com" target="_blank">www.pleora.com</a></P>
</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
		<title>PvBuffer Class Reference</title>
		<link href="doxygen.css" rel="stylesheet" type="text/css">
		<link href="tabs.css" rel="stylesheet" type="text/css">
	</head>
	<body>
	<div class="contents">
		<div class="textblock">
			<h2><a href="http://www.pleora.com" target="_blank"><img src="logo.jpg" alt="Pleora Technologies Inc." align="middle" border="0"></a>
			eBUS SDK v4.1.4.3606 API</h2>
		</div>
	</div>
	<br>
	<br>
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_pv_buffer.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_pv_buffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PvBuffer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents a block of GigE Vision or USB3 Vision data in memory.  
 <a href="class_pv_buffer.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aec685815f08f9a47e7f8df24f8d90547"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#aec685815f08f9a47e7f8df24f8d90547">PvBuffer</a> (<a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30f">PvPayloadType</a> aPayloadType=<a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30faeb97a52f2036290b6213951f7782c841">PvPayloadTypeImage</a>)</td></tr>
<tr class="memdesc:aec685815f08f9a47e7f8df24f8d90547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#aec685815f08f9a47e7f8df24f8d90547">More...</a><br/></td></tr>
<tr class="separator:aec685815f08f9a47e7f8df24f8d90547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a035a8711b365606fd6ec2d9b609b6b37"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a035a8711b365606fd6ec2d9b609b6b37"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a035a8711b365606fd6ec2d9b609b6b37">~PvBuffer</a> ()</td></tr>
<tr class="memdesc:a035a8711b365606fd6ec2d9b609b6b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="separator:a035a8711b365606fd6ec2d9b609b6b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12443f42dd7cc60f6f158cc0b433122"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30f">PvPayloadType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#af12443f42dd7cc60f6f158cc0b433122">GetPayloadType</a> () const </td></tr>
<tr class="memdesc:af12443f42dd7cc60f6f158cc0b433122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the payload type currently used by the buffer.  <a href="#af12443f42dd7cc60f6f158cc0b433122">More...</a><br/></td></tr>
<tr class="separator:af12443f42dd7cc60f6f158cc0b433122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e84f98d2c01c33aa6d58343fc242fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_image.html">PvImage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#aa0e84f98d2c01c33aa6d58343fc242fc">GetImage</a> ()</td></tr>
<tr class="memdesc:aa0e84f98d2c01c33aa6d58343fc242fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer. ">PvImage</a> interface to the buffer.  <a href="#aa0e84f98d2c01c33aa6d58343fc242fc">More...</a><br/></td></tr>
<tr class="separator:aa0e84f98d2c01c33aa6d58343fc242fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b18ddca1320afb60baceebcf0f395d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_pv_image.html">PvImage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#ab6b18ddca1320afb60baceebcf0f395d">GetImage</a> () const </td></tr>
<tr class="memdesc:ab6b18ddca1320afb60baceebcf0f395d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer. ">PvImage</a> interface to the buffer.  <a href="#ab6b18ddca1320afb60baceebcf0f395d">More...</a><br/></td></tr>
<tr class="separator:ab6b18ddca1320afb60baceebcf0f395d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeecd2a17dd53ef52ad1873bdb63df1b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_raw_data.html">PvRawData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#aeecd2a17dd53ef52ad1873bdb63df1b4">GetRawData</a> ()</td></tr>
<tr class="memdesc:aeecd2a17dd53ef52ad1873bdb63df1b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="class_pv_raw_data.html" title="Raw data interface to a PvBuffer. ">PvRawData</a> interface to the buffer.  <a href="#aeecd2a17dd53ef52ad1873bdb63df1b4">More...</a><br/></td></tr>
<tr class="separator:aeecd2a17dd53ef52ad1873bdb63df1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b8859e0461528b5a8d3be72e722549"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_pv_raw_data.html">PvRawData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a15b8859e0461528b5a8d3be72e722549">GetRawData</a> () const </td></tr>
<tr class="memdesc:a15b8859e0461528b5a8d3be72e722549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="class_pv_raw_data.html" title="Raw data interface to a PvBuffer. ">PvRawData</a> interface to the buffer.  <a href="#a15b8859e0461528b5a8d3be72e722549">More...</a><br/></td></tr>
<tr class="separator:a15b8859e0461528b5a8d3be72e722549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a5bc1a072b9c7fc2e7bba8e84555ac"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#ac2a5bc1a072b9c7fc2e7bba8e84555ac">GetDataPointer</a> () const </td></tr>
<tr class="memdesc:ac2a5bc1a072b9c7fc2e7bba8e84555ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the buffer's data pointer.  <a href="#ac2a5bc1a072b9c7fc2e7bba8e84555ac">More...</a><br/></td></tr>
<tr class="separator:ac2a5bc1a072b9c7fc2e7bba8e84555ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a569db0d7b1b3d79f28b7216407483795"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a569db0d7b1b3d79f28b7216407483795">GetDataPointer</a> ()</td></tr>
<tr class="memdesc:a569db0d7b1b3d79f28b7216407483795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the buffer's data pointer.  <a href="#a569db0d7b1b3d79f28b7216407483795">More...</a><br/></td></tr>
<tr class="separator:a569db0d7b1b3d79f28b7216407483795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75085028f5dab0f0ced4b12fbbf243ec"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a75085028f5dab0f0ced4b12fbbf243ec">GetID</a> () const </td></tr>
<tr class="memdesc:a75085028f5dab0f0ced4b12fbbf243ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the buffer's ID.  <a href="#a75085028f5dab0f0ced4b12fbbf243ec">More...</a><br/></td></tr>
<tr class="separator:a75085028f5dab0f0ced4b12fbbf243ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd62220f283c5b3c42444360390d2fdf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#acd62220f283c5b3c42444360390d2fdf">SetID</a> (uint64_t aValue)</td></tr>
<tr class="memdesc:acd62220f283c5b3c42444360390d2fdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the buffer's ID.  <a href="#acd62220f283c5b3c42444360390d2fdf">More...</a><br/></td></tr>
<tr class="separator:acd62220f283c5b3c42444360390d2fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb764127bb8864f866ef812cd2dc1e61"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#afb764127bb8864f866ef812cd2dc1e61">IsExtendedID</a> () const </td></tr>
<tr class="memdesc:afb764127bb8864f866ef812cd2dc1e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the buffer is currently in extended ID mode.  <a href="#afb764127bb8864f866ef812cd2dc1e61">More...</a><br/></td></tr>
<tr class="separator:afb764127bb8864f866ef812cd2dc1e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeed3a942fcceffbe043df3e79851f3b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#aaeed3a942fcceffbe043df3e79851f3b">GetAcquiredSize</a> () const </td></tr>
<tr class="memdesc:aaeed3a942fcceffbe043df3e79851f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size in bytes of the block received by the data receiver including, if present, additional chunk data and headers, optional padding.  <a href="#aaeed3a942fcceffbe043df3e79851f3b">More...</a><br/></td></tr>
<tr class="separator:aaeed3a942fcceffbe043df3e79851f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f9052f366299722a2b40a856edd9c51"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a5f9052f366299722a2b40a856edd9c51">GetRequiredSize</a> () const </td></tr>
<tr class="memdesc:a5f9052f366299722a2b40a856edd9c51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of buffer required to hold the acquired block including, if present, additional chunk data and headers, padding.  <a href="#a5f9052f366299722a2b40a856edd9c51">More...</a><br/></td></tr>
<tr class="separator:a5f9052f366299722a2b40a856edd9c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c1bb97c5cb8b165de7fa4e033f5afa"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a54c1bb97c5cb8b165de7fa4e033f5afa">GetSize</a> () const </td></tr>
<tr class="memdesc:a54c1bb97c5cb8b165de7fa4e033f5afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the buffer's allocated or attached size (total capacity) in bytes.  <a href="#a54c1bb97c5cb8b165de7fa4e033f5afa">More...</a><br/></td></tr>
<tr class="separator:a54c1bb97c5cb8b165de7fa4e033f5afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec5abd18467aa4855a6ba46e22c6b02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a1ec5abd18467aa4855a6ba46e22c6b02">Reset</a> (<a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30f">PvPayloadType</a> aPayloadType=<a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30faeb97a52f2036290b6213951f7782c841">PvPayloadTypeImage</a>)</td></tr>
<tr class="memdesc:a1ec5abd18467aa4855a6ba46e22c6b02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstruct the object with a new payload type.  <a href="#a1ec5abd18467aa4855a6ba46e22c6b02">More...</a><br/></td></tr>
<tr class="separator:a1ec5abd18467aa4855a6ba46e22c6b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29ff9092536ed20f600b53d151df653"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#ae29ff9092536ed20f600b53d151df653">Alloc</a> (uint32_t aSize)</td></tr>
<tr class="memdesc:ae29ff9092536ed20f600b53d151df653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for this <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a>.  <a href="#ae29ff9092536ed20f600b53d151df653">More...</a><br/></td></tr>
<tr class="separator:ae29ff9092536ed20f600b53d151df653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a897632d211ffca6e730d13f58447d1d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a897632d211ffca6e730d13f58447d1d9">Free</a> ()</td></tr>
<tr class="memdesc:a897632d211ffca6e730d13f58447d1d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees (de-allocates) the buffer's internal memory.  <a href="#a897632d211ffca6e730d13f58447d1d9">More...</a><br/></td></tr>
<tr class="separator:a897632d211ffca6e730d13f58447d1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88205cb108badafa8c268600fdaaa197"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a88205cb108badafa8c268600fdaaa197">Attach</a> (void *aBuffer, uint32_t aSize)</td></tr>
<tr class="memdesc:a88205cb108badafa8c268600fdaaa197"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach this <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> to an external memory buffer.  <a href="#a88205cb108badafa8c268600fdaaa197">More...</a><br/></td></tr>
<tr class="separator:a88205cb108badafa8c268600fdaaa197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ba206acb0a787322b1028ff67adb2a"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a96ba206acb0a787322b1028ff67adb2a">Detach</a> ()</td></tr>
<tr class="memdesc:a96ba206acb0a787322b1028ff67adb2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases an attached memory buffer.  <a href="#a96ba206acb0a787322b1028ff67adb2a">More...</a><br/></td></tr>
<tr class="separator:a96ba206acb0a787322b1028ff67adb2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c94c135858e93b441131527b35b8e1"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a90c94c135858e93b441131527b35b8e1">GetBlockID</a> () const </td></tr>
<tr class="memdesc:a90c94c135858e93b441131527b35b8e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the block ID.  <a href="#a90c94c135858e93b441131527b35b8e1">More...</a><br/></td></tr>
<tr class="separator:a90c94c135858e93b441131527b35b8e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6089cf8573309e856216d0700beecca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#ab6089cf8573309e856216d0700beecca">GetOperationResult</a> () const </td></tr>
<tr class="memdesc:ab6089cf8573309e856216d0700beecca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of aOperationResult when this buffer was last received through a <a class="el" href="class_pv_stream.html" title="Receive data from a GigE Vision or USB3 Vision transmitter. ">PvStream</a>.  <a href="#ab6089cf8573309e856216d0700beecca">More...</a><br/></td></tr>
<tr class="separator:ab6089cf8573309e856216d0700beecca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03fdee47f9fed59c0e49f786afc5fb11"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a03fdee47f9fed59c0e49f786afc5fb11">GetTimestamp</a> () const </td></tr>
<tr class="memdesc:a03fdee47f9fed59c0e49f786afc5fb11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the buffer's timestamp.  <a href="#a03fdee47f9fed59c0e49f786afc5fb11">More...</a><br/></td></tr>
<tr class="separator:a03fdee47f9fed59c0e49f786afc5fb11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520ced730801caff7d8e2a5d31df0989"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a520ced730801caff7d8e2a5d31df0989">GetReceptionTime</a> () const </td></tr>
<tr class="memdesc:a520ced730801caff7d8e2a5d31df0989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the buffer's reception timestamp.  <a href="#a520ced730801caff7d8e2a5d31df0989">More...</a><br/></td></tr>
<tr class="separator:a520ced730801caff7d8e2a5d31df0989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7359326b0c36f66f2a09f842d50186c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a7359326b0c36f66f2a09f842d50186c0">SetTimestamp</a> (uint64_t aTimestamp)</td></tr>
<tr class="memdesc:a7359326b0c36f66f2a09f842d50186c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the timestamp to place in the block leader.  <a href="#a7359326b0c36f66f2a09f842d50186c0">More...</a><br/></td></tr>
<tr class="separator:a7359326b0c36f66f2a09f842d50186c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e080fe7f6736d553cbd2aef1759d9c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#aa2e080fe7f6736d553cbd2aef1759d9c">GetPacketsRecoveredCount</a> () const </td></tr>
<tr class="memdesc:aa2e080fe7f6736d553cbd2aef1759d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of lost packets successfully recovered by packet resend requests. Duplicate received packets are not counted.  <a href="#aa2e080fe7f6736d553cbd2aef1759d9c">More...</a><br/></td></tr>
<tr class="separator:aa2e080fe7f6736d553cbd2aef1759d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a598a8b9523090ced14a2cdbc5731bba3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a598a8b9523090ced14a2cdbc5731bba3">GetPacketsRecoveredSingleResendCount</a> () const </td></tr>
<tr class="memdesc:a598a8b9523090ced14a2cdbc5731bba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of lost packets successfully recovered by packet resend requests without any resend request retries.  <a href="#a598a8b9523090ced14a2cdbc5731bba3">More...</a><br/></td></tr>
<tr class="separator:a598a8b9523090ced14a2cdbc5731bba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0770ef8c08f8fb45c0143fe7899e66"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a6e0770ef8c08f8fb45c0143fe7899e66">GetResendGroupRequestedCount</a> () const </td></tr>
<tr class="memdesc:a6e0770ef8c08f8fb45c0143fe7899e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of resend requests issued by the data receiver.  <a href="#a6e0770ef8c08f8fb45c0143fe7899e66">More...</a><br/></td></tr>
<tr class="separator:a6e0770ef8c08f8fb45c0143fe7899e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf1e0a44fdea528a1f4eea3dd45520b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a8bf1e0a44fdea528a1f4eea3dd45520b">GetResendPacketRequestedCount</a> () const </td></tr>
<tr class="memdesc:a8bf1e0a44fdea528a1f4eea3dd45520b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of packets the data receiver requests with ResendGroupRequested.  <a href="#a8bf1e0a44fdea528a1f4eea3dd45520b">More...</a><br/></td></tr>
<tr class="separator:a8bf1e0a44fdea528a1f4eea3dd45520b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad72d9219b02d107becadc936b1df18d0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#ad72d9219b02d107becadc936b1df18d0">GetLostPacketCount</a> () const </td></tr>
<tr class="memdesc:ad72d9219b02d107becadc936b1df18d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packets that were not successfully delivered when this <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> was filled by the data receiver.  <a href="#ad72d9219b02d107becadc936b1df18d0">More...</a><br/></td></tr>
<tr class="separator:ad72d9219b02d107becadc936b1df18d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d271e8803623ed3141d04226d1a4b0c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a2d271e8803623ed3141d04226d1a4b0c">GetIgnoredPacketCount</a> () const </td></tr>
<tr class="memdesc:a2d271e8803623ed3141d04226d1a4b0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packets received that were ignored when this buffer was filled by the data receiver.  <a href="#a2d271e8803623ed3141d04226d1a4b0c">More...</a><br/></td></tr>
<tr class="separator:a2d271e8803623ed3141d04226d1a4b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3ec6d9aa3ce9175a55a9f268853e53"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#acc3ec6d9aa3ce9175a55a9f268853e53">GetRedundantPacketCount</a> () const </td></tr>
<tr class="memdesc:acc3ec6d9aa3ce9175a55a9f268853e53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of packets received more than once.  <a href="#acc3ec6d9aa3ce9175a55a9f268853e53">More...</a><br/></td></tr>
<tr class="separator:acc3ec6d9aa3ce9175a55a9f268853e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1886e2851dde5a709a1109804fe142"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a8b1886e2851dde5a709a1109804fe142">GetPacketOutOfOrderCount</a> () const </td></tr>
<tr class="memdesc:a8b1886e2851dde5a709a1109804fe142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of packets received out of order.  <a href="#a8b1886e2851dde5a709a1109804fe142">More...</a><br/></td></tr>
<tr class="separator:a8b1886e2851dde5a709a1109804fe142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31cd126a8ccf4e9ae24fbadb42738f39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a31cd126a8ccf4e9ae24fbadb42738f39">GetMissingPacketIdsCount</a> (uint32_t &amp;aCount)</td></tr>
<tr class="memdesc:a31cd126a8ccf4e9ae24fbadb42738f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of missing packet groups that represent unpopulated areas of memory in this buffer.  <a href="#a31cd126a8ccf4e9ae24fbadb42738f39">More...</a><br/></td></tr>
<tr class="separator:a31cd126a8ccf4e9ae24fbadb42738f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1cdb64996318a1dceb0be5bf16dc13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a8e1cdb64996318a1dceb0be5bf16dc13">GetMissingPacketIds</a> (uint32_t aIndex, uint32_t &amp;aPacketIdLow, uint32_t &amp;aPacketIdHigh)</td></tr>
<tr class="memdesc:a8e1cdb64996318a1dceb0be5bf16dc13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a missing packet group that represents an unpopulated area of memory in this buffer.  <a href="#a8e1cdb64996318a1dceb0be5bf16dc13">More...</a><br/></td></tr>
<tr class="separator:a8e1cdb64996318a1dceb0be5bf16dc13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af05140436fd443ce5abcf6a54832ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a0af05140436fd443ce5abcf6a54832ec">HasChunks</a> () const </td></tr>
<tr class="memdesc:a0af05140436fd443ce5abcf6a54832ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the buffer has data chunks.  <a href="#a0af05140436fd443ce5abcf6a54832ec">More...</a><br/></td></tr>
<tr class="separator:a0af05140436fd443ce5abcf6a54832ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8586236cfce7b6149a0aeba5530616c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#ac8586236cfce7b6149a0aeba5530616c">GetChunkCount</a> ()</td></tr>
<tr class="memdesc:ac8586236cfce7b6149a0aeba5530616c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of data chunks in the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a>.  <a href="#ac8586236cfce7b6149a0aeba5530616c">More...</a><br/></td></tr>
<tr class="separator:ac8586236cfce7b6149a0aeba5530616c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8377362f7f1f734dc2c013d280a5937a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a8377362f7f1f734dc2c013d280a5937a">GetChunkIDByIndex</a> (uint32_t aIndex, uint32_t &amp;aID)</td></tr>
<tr class="memdesc:a8377362f7f1f734dc2c013d280a5937a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ID of a chunk based on its index.  <a href="#a8377362f7f1f734dc2c013d280a5937a">More...</a><br/></td></tr>
<tr class="separator:a8377362f7f1f734dc2c013d280a5937a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7235900e888c98c167c41db82ac54ac6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a7235900e888c98c167c41db82ac54ac6">GetChunkSizeByIndex</a> (uint32_t aIndex)</td></tr>
<tr class="memdesc:a7235900e888c98c167c41db82ac54ac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size in bytes of the data chunk at zero-based aIndex.  <a href="#a7235900e888c98c167c41db82ac54ac6">More...</a><br/></td></tr>
<tr class="separator:a7235900e888c98c167c41db82ac54ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96371f3d9f3728cd17ecf663b9af7ec"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#ae96371f3d9f3728cd17ecf663b9af7ec">GetChunkSizeByID</a> (uint32_t aID)</td></tr>
<tr class="memdesc:ae96371f3d9f3728cd17ecf663b9af7ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size in bytes of the data chunk identified by aID.  <a href="#ae96371f3d9f3728cd17ecf663b9af7ec">More...</a><br/></td></tr>
<tr class="separator:ae96371f3d9f3728cd17ecf663b9af7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afffd2ac9e5755b95263be72b331e5176"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#afffd2ac9e5755b95263be72b331e5176">GetChunkRawDataByIndex</a> (uint32_t aIndex)</td></tr>
<tr class="memdesc:afffd2ac9e5755b95263be72b331e5176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const pointer to the data chunk at zero-based aIndex.  <a href="#afffd2ac9e5755b95263be72b331e5176">More...</a><br/></td></tr>
<tr class="separator:afffd2ac9e5755b95263be72b331e5176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a00dd94c912ff14e487debf9599f7ae"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a1a00dd94c912ff14e487debf9599f7ae">GetChunkRawDataByID</a> (uint32_t aID)</td></tr>
<tr class="memdesc:a1a00dd94c912ff14e487debf9599f7ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const pointer to the data chunk with its ID matching aID.  <a href="#a1a00dd94c912ff14e487debf9599f7ae">More...</a><br/></td></tr>
<tr class="separator:a1a00dd94c912ff14e487debf9599f7ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74111fb09e76b9f08124d75febda987"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#ac74111fb09e76b9f08124d75febda987">GetPayloadSize</a> () const </td></tr>
<tr class="memdesc:ac74111fb09e76b9f08124d75febda987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns payload size in bytes, excluding any extra padding.  <a href="#ac74111fb09e76b9f08124d75febda987">More...</a><br/></td></tr>
<tr class="separator:ac74111fb09e76b9f08124d75febda987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afedeb78adc823aff996d5682f4fdeac0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#afedeb78adc823aff996d5682f4fdeac0">IsHeaderValid</a> () const </td></tr>
<tr class="memdesc:afedeb78adc823aff996d5682f4fdeac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this buffer has valid header (GVSP) information.  <a href="#afedeb78adc823aff996d5682f4fdeac0">More...</a><br/></td></tr>
<tr class="separator:afedeb78adc823aff996d5682f4fdeac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7d71796bff6856871b1d6468a1f2df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_buffer.html#a3c7d71796bff6856871b1d6468a1f2df">IsTrailerValid</a> () const </td></tr>
<tr class="memdesc:a3c7d71796bff6856871b1d6468a1f2df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this buffer has valid trailer (GVSP) information.  <a href="#a3c7d71796bff6856871b1d6468a1f2df">More...</a><br/></td></tr>
<tr class="separator:a3c7d71796bff6856871b1d6468a1f2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:afbebe17463fe09a03e19c5ac67193db8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afbebe17463fe09a03e19c5ac67193db8"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>PvPipeline</b></td></tr>
<tr class="separator:afbebe17463fe09a03e19c5ac67193db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aba78b7171fe59591d8221ded00e204"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5aba78b7171fe59591d8221ded00e204"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>PvStream</b></td></tr>
<tr class="separator:a5aba78b7171fe59591d8221ded00e204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7bc3879443389244a8500bf7e99744"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd7bc3879443389244a8500bf7e99744"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>PvBufferConverter</b></td></tr>
<tr class="separator:acd7bc3879443389244a8500bf7e99744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1fa79f796027b5c5d1f0462ec149ce7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1fa79f796027b5c5d1f0462ec149ce7"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>PvBufferConverterRGBFilter</b></td></tr>
<tr class="separator:ab1fa79f796027b5c5d1f0462ec149ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf38d0d115717022f41fc66848ff4e71"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf38d0d115717022f41fc66848ff4e71"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>PvDeInterlacer</b></td></tr>
<tr class="separator:abf38d0d115717022f41fc66848ff4e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7b918eec3852cf47fde67a519f6308"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb7b918eec3852cf47fde67a519f6308"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>PvTransmitterGEV</b></td></tr>
<tr class="separator:acb7b918eec3852cf47fde67a519f6308"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a block of GigE Vision or USB3 Vision data in memory. </p>
<p>A <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> object is typically used to receive data from a GigE Vision or USB3 Vision transmitter or to transmit data to a GigE Vision receiver. To learn about receiving data from a GigE Vision or USB3 Vision transmitter, see <a class="el" href="class_pv_stream.html" title="Receive data from a GigE Vision or USB3 Vision transmitter. ">PvStream</a>. To learn about transmitting GigE Vision data to a GigE Vision receiver, see <a class="el" href="class_pv_transmitter_g_e_v.html" title="Class for transmitting blocks using the GigE Vision streaming protocol. ">PvTransmitterGEV</a>.</p>
<p>A block of GigE Vision or USB3 Vision data has an associated payload which can be an image, raw data, file, chunk data, extended chunk data or device specific.</p>
<p>In order to access the payload specific data, use methods like <a class="el" href="class_pv_buffer.html#aa0e84f98d2c01c33aa6d58343fc242fc" title="Returns the PvImage interface to the buffer. ">PvBuffer::GetImage</a> in order to get a pointer to an interface giving you access to payload specific methods and properties.</p>
<p>The current payload type of a <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> can be determined by using the <a class="el" href="class_pv_buffer.html#af12443f42dd7cc60f6f158cc0b433122" title="Returns the payload type currently used by the buffer. ">PvBuffer::GetPayloadType</a> method.</p>
<p>In this section:</p>
<ul>
<li><a href="#configuring">Creating and configuring buffers</a></li>
<li><a href="#accessing">Accessing payload type specific data</a></li>
<li><a href="#processing">Processing images</a></li>
</ul>
<h2 id="configuring">Creating and configuring buffers</h2>
<p><b>To create and configure buffers:</b></p>
<ol type="1">
<li>Create several buffers using the default constructor.</li>
<li>Set the size of the buffer. The method you use depends on whether you want to use an internally or externally controlled block of memory:<ul>
<li>To use memory that the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> object allocates and owns, use <a class="el" href="class_pv_buffer.html#ae29ff9092536ed20f600b53d151df653" title="Allocates memory for this PvBuffer. ">Alloc</a>.</li>
<li>To use memory that you control (external to the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> object), use <a class="el" href="class_pv_buffer.html#a88205cb108badafa8c268600fdaaa197" title="Attach this PvBuffer to an external memory buffer. ">Attach</a>.</li>
</ul>
</li>
</ol>
<h2 id="accessing">Accessing payload type specific data</h2>
<p><b>To determine the payload type and access payload type specific data:</b></p>
<ol type="1">
<li>Retrieve the <a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30f" title="GVSP payload type. ">PvPayloadType</a> using <a class="el" href="class_pv_buffer.html#af12443f42dd7cc60f6f158cc0b433122" title="Returns the payload type currently used by the buffer. ">PvBuffer::GetPayloadType</a></li>
<li>If <a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30f" title="GVSP payload type. ">PvPayloadType</a> is <a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30faeb97a52f2036290b6213951f7782c841">PvPayloadTypeImage</a>, retrieve <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer. ">PvImage</a> pointer from your <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a></li>
<li>Access image specific data through the <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer. ">PvImage</a> pointer, like <a class="el" href="class_pv_image.html#a4091630b68604e1a7045f301c1f220c0" title="Get the image&#39;s width. ">PvImage::GetWidth</a>, <a class="el" href="class_pv_image.html#ab4dbc5fd430621436c1598e2ee96ba65" title="Get the image&#39;s height. ">PvImage::GetHeight</a>, etc.</li>
<li>There is no need to release or delete the <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer. ">PvImage</a> pointer. It is valid as long as the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> exists.</li>
</ol>
<h2 id="processing">Processing images</h2>
<p><b>To process an image:</b></p>
<ol type="1">
<li>Retrieve a <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer. ">PvImage</a> interface to the buffer use <a class="el" href="class_pv_buffer.html#aa0e84f98d2c01c33aa6d58343fc242fc" title="Returns the PvImage interface to the buffer. ">GetImage</a></li>
<li>Test the success of the image acquisition. Use the <em>aOperationResult</em> parameter in <a class="el" href="class_pv_stream.html#a8bcce3d5c1f0b35e1db259fa82640e40" title="Attempt to retrieve a queued buffer. ">PvStream::RetrieveBuffer</a> or <a class="el" href="class_pv_buffer.html#ab6089cf8573309e856216d0700beecca" title="Returns the value of aOperationResult when this buffer was last received through a PvStream...">PvBuffer::GetOperationResult</a></li>
<li>Process the image using your own code. You may process the image in place, if you wish. Use:<ul>
<li>PvImage::GetAcquiredSize</li>
<li><a class="el" href="class_pv_image.html#ab4dbc5fd430621436c1598e2ee96ba65" title="Get the image&#39;s height. ">PvImage::GetHeight</a> and <a class="el" href="class_pv_image.html#a4091630b68604e1a7045f301c1f220c0" title="Get the image&#39;s width. ">PvImage::GetWidth</a></li>
<li><a class="el" href="class_pv_image.html#a5ace5c9515129b1459c7b26f0998ebc6" title="Get the image&#39;s horizontal offset. ">PvImage::GetOffsetX</a> and <a class="el" href="class_pv_image.html#a35d8c2ef8f857efe2a81f1b1db92aae9" title="Get the image&#39;s vertical offset. ">PvImage::GetOffsetY</a> </li>
</ul>
</li>
</ol>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aec685815f08f9a47e7f8df24f8d90547"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvBuffer::PvBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30f">PvPayloadType</a>&#160;</td>
          <td class="paramname"><em>aPayloadType</em> = <code><a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30faeb97a52f2036290b6213951f7782c841">PvPayloadTypeImage</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aPayloadType</td><td>The block type (default PvPayloadTypeImage). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ae29ff9092536ed20f600b53d151df653"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvBuffer::Alloc </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory for this <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aSize</td><td>The size of the buffer, in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7cac194e39fb420655ac75525f53714bc2c">PvResult::Code::NOT_ENOUGH_MEMORY</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a88205cb108badafa8c268600fdaaa197"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvBuffer::Attach </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>aBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attach this <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> to an external memory buffer. </p>
<p>To use an internal memory buffer, use <a class="el" href="class_pv_buffer.html#ae29ff9092536ed20f600b53d151df653" title="Allocates memory for this PvBuffer. ">Alloc</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aBuffer</td><td>A pointer to the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aSize</td><td>The size, in bytes, of the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa01691a7ea2f9fd92fb720c5477bcda1">PvResult::Code::INVALID_PARAMETER</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_pv_buffer.html#a96ba206acb0a787322b1028ff67adb2a" title="Releases an attached memory buffer. ">Detach</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a96ba206acb0a787322b1028ff67adb2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t * PvBuffer::Detach </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases an attached memory buffer. </p>
<p>Does nothing other then resetting the memory buffer pointer to NULL.</p>
<dl class="section return"><dt>Returns</dt><dd>The buffer's location in memory.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_pv_buffer.html#a88205cb108badafa8c268600fdaaa197" title="Attach this PvBuffer to an external memory buffer. ">Attach</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a897632d211ffca6e730d13f58447d1d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PvBuffer::Free </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees (de-allocates) the buffer's internal memory. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_pv_buffer.html#ae29ff9092536ed20f600b53d151df653" title="Allocates memory for this PvBuffer. ">Alloc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aaeed3a942fcceffbe043df3e79851f3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvBuffer::GetAcquiredSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the size in bytes of the block received by the data receiver including, if present, additional chunk data and headers, optional padding. </p>
<dl class="section return"><dt>Returns</dt><dd>The size, in bytes, of bytes received for this buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a90c94c135858e93b441131527b35b8e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t PvBuffer::GetBlockID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the block ID. </p>
<p>This method returns the block ID. The GigE Vision transmitter typically increments the value by 1 for each new image. You can use this value to ensure the blocks are in order and that none are missing. The value is unsigned and wraps around to 1 (skipping 0) when it reaches 65536.</p>
<dl class="section return"><dt>Returns</dt><dd>The block ID </dd></dl>

</div>
</div>
<a class="anchor" id="ac8586236cfce7b6149a0aeba5530616c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvBuffer::GetChunkCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of data chunks in the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a>. </p>
<p>If no data chunks are available, 0 is returned.</p>
<p>Counting chunks requires the chunks to be parsed and resolved which has a performance hit.</p>
<p>If you need to access chunks directly, you need to use this method to enumerate the chunks. If you access the chunks through GenICam, just use HasChunks to see if you need to attach the buffer the GenICam parameter array of the device.</p>
<dl class="section return"><dt>Returns</dt><dd>Data chunks count. 0 if no chunks are available. </dd></dl>

</div>
</div>
<a class="anchor" id="a8377362f7f1f734dc2c013d280a5937a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvBuffer::GetChunkIDByIndex </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>aID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the ID of a chunk based on its index. </p>
<p>If the index is out of range or the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> does not have any data chunk 0 is returned in aID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aIndex</td><td>Data chunk index. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aID</td><td>Data chunk ID for aIndex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="class_pv_result.html" title="Result information. ">PvResult</a> is used to captured the success or failure of the operation as 0 can be a valid chunk ID:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa4357271e02951867594e0cc932c12f8">PvResult::Code::NOT_FOUND</a> if the index is out of range or the buffer does not have any chunks </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a1a00dd94c912ff14e487debf9599f7ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t * PvBuffer::GetChunkRawDataByID </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const pointer to the data chunk with its ID matching aID. </p>
<p>If the aID chunk is not found or the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> does not have any chunks NULL is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aID</td><td>Data chunk ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Point to chunk data. NULL if the chunk ID is not found. </dd></dl>

</div>
</div>
<a class="anchor" id="afffd2ac9e5755b95263be72b331e5176"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t * PvBuffer::GetChunkRawDataByIndex </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const pointer to the data chunk at zero-based aIndex. </p>
<p>Chunks are enumerated from the end of the payload data to its beginning. If the index is out of range or the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> does not have any data chunk NULL is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aIndex</td><td>Data chunk index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Point to chunk data. NULL if the index is out of range. </dd></dl>

</div>
</div>
<a class="anchor" id="ae96371f3d9f3728cd17ecf663b9af7ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvBuffer::GetChunkSizeByID </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size in bytes of the data chunk identified by aID. </p>
<p>If the aID chunk is not found or the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> does not have any chunks 0 is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aID</td><td>Data chunk ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Data chunk size. 0 if the chunk ID is not found. </dd></dl>

</div>
</div>
<a class="anchor" id="a7235900e888c98c167c41db82ac54ac6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvBuffer::GetChunkSizeByIndex </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size in bytes of the data chunk at zero-based aIndex. </p>
<p>Chunks are enumerated from the end of the payload data to its beginning. If the index is out of range or the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> does not have any data chunk 0 is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aIndex</td><td>Data chunk index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Data chunk size. 0 if the index is out of range. </dd></dl>

</div>
</div>
<a class="anchor" id="ac2a5bc1a072b9c7fc2e7bba8e84555ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t * PvBuffer::GetDataPointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the buffer's data pointer. </p>
<p>The <a class="el" href="class_pv_buffer.html#ac2a5bc1a072b9c7fc2e7bba8e84555ac" title="Get the buffer&#39;s data pointer. ">GetDataPointer</a> method returns a pointer to the buffer. To set the memory location, use <a class="el" href="class_pv_buffer.html#ae29ff9092536ed20f600b53d151df653" title="Allocates memory for this PvBuffer. ">Alloc</a> or <a class="el" href="class_pv_buffer.html#a88205cb108badafa8c268600fdaaa197" title="Attach this PvBuffer to an external memory buffer. ">Attach</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the memory pointer. </dd></dl>

</div>
</div>
<a class="anchor" id="a569db0d7b1b3d79f28b7216407483795"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t * PvBuffer::GetDataPointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the buffer's data pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the memory pointer. </dd></dl>

</div>
</div>
<a class="anchor" id="a75085028f5dab0f0ced4b12fbbf243ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t PvBuffer::GetID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the buffer's ID. </p>
<p>See <a class="el" href="class_pv_buffer.html#acd62220f283c5b3c42444360390d2fdf" title="Set the buffer&#39;s ID. ">SetID</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>The buffer's ID. See <a class="el" href="class_pv_buffer.html#acd62220f283c5b3c42444360390d2fdf" title="Set the buffer&#39;s ID. ">SetID</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a2d271e8803623ed3141d04226d1a4b0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvBuffer::GetIgnoredPacketCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Packets received that were ignored when this buffer was filled by the data receiver. </p>
<dl class="section return"><dt>Returns</dt><dd>The ignored packet count </dd></dl>

</div>
</div>
<a class="anchor" id="aa0e84f98d2c01c33aa6d58343fc242fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_image.html">PvImage</a> * PvBuffer::GetImage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer. ">PvImage</a> interface to the buffer. </p>
<p>If the payload type of the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> is PvPayloadTypeImage, a pointer to the <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer. ">PvImage</a> interface of the buffer is returned.</p>
<p>If the payload type of the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> is NOT PvPayloadTypeImage, a NULL pointer is returned.</p>
<p>This <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer. ">PvImage</a> pointer is owned by the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> and does not need to be released after use. It is valid as long as the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> exists.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer. ">PvImage</a> interface or NULL, depending on payload type. </dd></dl>

</div>
</div>
<a class="anchor" id="ab6b18ddca1320afb60baceebcf0f395d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_pv_image.html">PvImage</a> * PvBuffer::GetImage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer. ">PvImage</a> interface to the buffer. </p>
<p>Const version.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer. ">PvImage</a> interface or NULL, depending on payload type. </dd></dl>

</div>
</div>
<a class="anchor" id="ad72d9219b02d107becadc936b1df18d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvBuffer::GetLostPacketCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Packets that were not successfully delivered when this <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> was filled by the data receiver. </p>
<dl class="section return"><dt>Returns</dt><dd>The lost packet count </dd></dl>

</div>
</div>
<a class="anchor" id="a8e1cdb64996318a1dceb0be5bf16dc13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvBuffer::GetMissingPacketIds </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>aPacketIdLow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>aPacketIdHigh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a missing packet group that represents an unpopulated area of memory in this buffer. </p>
<dl class="section note"><dt>Note</dt><dd>This is an advanced feature that requires knowledge of how GigE Vision data is transmitted. Refer to <a class="el" href="class_pv_buffer.html#a31cd126a8ccf4e9ae24fbadb42738f39" title="Get the number of missing packet groups that represent unpopulated areas of memory in this buffer...">GetMissingPacketIdsCount</a> for further details on how this feature is used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aIndex</td><td>The index of the missing packet group being retrieved. </td></tr>
    <tr><td class="paramname">aPacketIdLow</td><td>The first packet of a range of missing packets. </td></tr>
    <tr><td class="paramname">aPacketIdHigh</td><td>The last packet of a range of missing packets. A value of 0xFFFFFF ( or 0xFFFFFFFF for ExtendedID ) indicates that the last packet of the block went missing and therefore the actual size of the block is unknown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> or <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca79f3ef17e3d22d3ac8a6840007ba261d">PvResult::Code::NOT_IMPLEMENTED</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a31cd126a8ccf4e9ae24fbadb42738f39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvBuffer::GetMissingPacketIdsCount </td>
          <td>(</td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>aCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of missing packet groups that represent unpopulated areas of memory in this buffer. </p>
<dl class="section note"><dt>Note</dt><dd>This is an advanced feature that requires knowledge of how GigE Vision data is transmitted.</dd></dl>
<p>When receiving data from a GigE Vision transmitter, network conditions may prevent the successful delivery of all the data for a given block. Although the eBUS data receiver provides a mechanism for requesting lost packets, there are cases when it is desirable to ignore missing packets and make use of a buffer that contains missing information. In some cases, there are portions of a block that are less important and can thus be disregarded. <a class="el" href="class_pv_buffer.html#a31cd126a8ccf4e9ae24fbadb42738f39" title="Get the number of missing packet groups that represent unpopulated areas of memory in this buffer...">GetMissingPacketIdsCount</a> and <a class="el" href="class_pv_buffer.html#a8e1cdb64996318a1dceb0be5bf16dc13" title="Get a missing packet group that represents an unpopulated area of memory in this buffer. ">GetMissingPacketIds</a> can provide information about which packets were lost. To use this feature take note of the following procedure:</p>
<ul>
<li>Enable the feature that causes the data receiver to keep track of missing packets (see the <a href="streamparametersGEV.html#EnableMissingPacketsList">EnableMissingPacketsList</a> property of <a class="el" href="class_pv_stream.html" title="Receive data from a GigE Vision or USB3 Vision transmitter. ">PvStream</a>).</li>
<li>Optionally disable the mechanism that requests lost packets (see the <a href="streamparametersGEV.html#RequestMissingPackets">RequestMissingPackets</a> property of <a class="el" href="class_pv_stream.html" title="Receive data from a GigE Vision or USB3 Vision transmitter. ">PvStream</a>).</li>
<li>Check the operation result when a new block is received (see <a class="el" href="class_pv_buffer.html#ab6089cf8573309e856216d0700beecca" title="Returns the value of aOperationResult when this buffer was last received through a PvStream...">PvBuffer::GetOperationResult</a>).</li>
<li>If the operation result is <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca19573c67c2127b0f06f0031f3549fd2b">PvResult::Code::MISSING_PACKETS</a>, call <a class="el" href="class_pv_buffer.html#a31cd126a8ccf4e9ae24fbadb42738f39" title="Get the number of missing packet groups that represent unpopulated areas of memory in this buffer...">GetMissingPacketIdsCount</a> to determine how many groups of packets are missing.</li>
<li>Iterate through the missing packet groups using <a class="el" href="class_pv_buffer.html#a8e1cdb64996318a1dceb0be5bf16dc13" title="Get a missing packet group that represents an unpopulated area of memory in this buffer. ">GetMissingPacketIds</a>.</li>
<li>Note that there is no particular order to the missing packet groups that are returned.</li>
<li>Take note of the packet size set on the GigE Vision transmitter from which you are receiving to determine the areas of the payload where information is missing.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aCount</td><td>The number of missing packet groups that represent unpopulated areas of memory in this buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> or <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca79f3ef17e3d22d3ac8a6840007ba261d">PvResult::Code::NOT_IMPLEMENTED</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ab6089cf8573309e856216d0700beecca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvBuffer::GetOperationResult </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of aOperationResult when this buffer was last received through a <a class="el" href="class_pv_stream.html" title="Receive data from a GigE Vision or USB3 Vision transmitter. ">PvStream</a>. </p>
<p>Buffers with BUFFER_TOO_SMALL, ABORTED, NOT_CONNECTED and NO_MORE_ITEM operation results are never returned to the user with <a class="el" href="class_pv_pipeline.html" title="Helper class for receiving data from a GigE Vision or USB3 Vision transmitter. ">PvPipeline</a>. <a class="el" href="class_pv_pipeline.html" title="Helper class for receiving data from a GigE Vision or USB3 Vision transmitter. ">PvPipeline</a> handles these operation results internally without returning the buffers. Buffers with these operation results can only reach the user when using <a class="el" href="class_pv_stream.html" title="Receive data from a GigE Vision or USB3 Vision transmitter. ">PvStream</a> directly.</p>
<dl class="section return"><dt>Returns</dt><dd>Result of the acquisition operation; Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca57f682171369be7611392e0fe458de73">PvResult::Code::NOT_INITIALIZED</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca8044711331afcc8f9607defdeb4f897f">PvResult::Code::TIMEOUT</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca02e7e13232d736f9215df059aa92280f">PvResult::Code::ABORTED</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca19573c67c2127b0f06f0031f3549fd2b">PvResult::Code::MISSING_PACKETS</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca37cf2b6eb84b2f3286393bc9108cfab4">PvResult::Code::BUFFER_TOO_SMALL</a>:</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7cafe66d844ac9cddeebf0cae1dd0283cd4">PvResult::Code::IMAGE_ERROR</a> for images with grabber issues like data overrun or missing lines (complete or partial)</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca57df90fcb05e5b2a6c3ec82b0d1ca7b0">PvResult::Code::RESENDS_FAILURE</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caaf1d8836efaecbc4c70e38cbba38a9ad">PvResult::Code::TOO_MANY_RESENDS</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca122dbe89cae082c2990fb7481c000337">PvResult::Code::TOO_MANY_CONSECUTIVE_RESENDS</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa7ae611c1cc27c16e4eb3b05cf988dc6">PvResult::Code::INVALID_DATA_FORMAT</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca4e0a3590808a33d9fa4c4742690397d8">PvResult::Code::AUTO_ABORTED</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_pv_stream.html#a8bcce3d5c1f0b35e1db259fa82640e40" title="Attempt to retrieve a queued buffer. ">PvStream::RetrieveBuffer</a>, <a class="el" href="class_pv_pipeline.html#aa1924fc80cff8d6c566f1429e0dc682f" title="Retrieve the next acquired block. ">PvPipeline::RetrieveNextBuffer</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8b1886e2851dde5a709a1109804fe142"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvBuffer::GetPacketOutOfOrderCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of packets received out of order. </p>
<dl class="section return"><dt>Returns</dt><dd>The packet out of order count </dd></dl>

</div>
</div>
<a class="anchor" id="aa2e080fe7f6736d553cbd2aef1759d9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvBuffer::GetPacketsRecoveredCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of lost packets successfully recovered by packet resend requests. Duplicate received packets are not counted. </p>
<dl class="section return"><dt>Returns</dt><dd>The expected resend count </dd></dl>

</div>
</div>
<a class="anchor" id="a598a8b9523090ced14a2cdbc5731bba3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvBuffer::GetPacketsRecoveredSingleResendCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of lost packets successfully recovered by packet resend requests without any resend request retries. </p>
<dl class="section return"><dt>Returns</dt><dd>The expected resend count </dd></dl>

</div>
</div>
<a class="anchor" id="ac74111fb09e76b9f08124d75febda987"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvBuffer::GetPayloadSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns payload size in bytes, excluding any extra padding. </p>
<p>Gets the size in bytes of the block received by the data receiver including, if present, additional chunk data and headers.</p>
<p>Different than GetAcquiredSize as it does not include optional additional padding when data chunks are present.</p>
<p>If data chunks are not present, this method returns the same value as GetAcquiredSize as extra padding is only an issue when data chunks are present.</p>
<p>This method is required in order to parse the chunk data using GenICam.</p>
<dl class="section return"><dt>Returns</dt><dd>Payload size in bytes, excluding any extra padding. </dd></dl>

</div>
</div>
<a class="anchor" id="af12443f42dd7cc60f6f158cc0b433122"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30f">PvPayloadType</a> PvBuffer::GetPayloadType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the payload type currently used by the buffer. </p>
<p>If data chunks are available, the buffer payload type is the same as if no data chunks were available. Use GetChunkCount to determine if chunks are available.</p>
<dl class="section return"><dt>Returns</dt><dd>PvPayloadType The current payload type for the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="aeecd2a17dd53ef52ad1873bdb63df1b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_raw_data.html">PvRawData</a> * PvBuffer::GetRawData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="class_pv_raw_data.html" title="Raw data interface to a PvBuffer. ">PvRawData</a> interface to the buffer. </p>
<p>If the payload type of the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> is PvPayloadTypeRawData, a pointer to the <a class="el" href="class_pv_raw_data.html" title="Raw data interface to a PvBuffer. ">PvRawData</a> interface of the buffer is returned.</p>
<p>If the payload type of the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> is NOT PvPayloadTypeRawData, a NULL pointer is returned.</p>
<p>This <a class="el" href="class_pv_raw_data.html" title="Raw data interface to a PvBuffer. ">PvRawData</a> pointer is owned by the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> and does not need to be released after use. It is valid as long as the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> exists.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <a class="el" href="class_pv_raw_data.html" title="Raw data interface to a PvBuffer. ">PvRawData</a> interface or NULL, depending on payload type. </dd></dl>

</div>
</div>
<a class="anchor" id="a15b8859e0461528b5a8d3be72e722549"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_pv_raw_data.html">PvRawData</a> * PvBuffer::GetRawData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="class_pv_raw_data.html" title="Raw data interface to a PvBuffer. ">PvRawData</a> interface to the buffer. </p>
<p>Const version.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <a class="el" href="class_pv_raw_data.html" title="Raw data interface to a PvBuffer. ">PvRawData</a> interface or NULL, depending on payload type. </dd></dl>

</div>
</div>
<a class="anchor" id="a520ced730801caff7d8e2a5d31df0989"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t PvBuffer::GetReceptionTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the buffer's reception timestamp. </p>
<dl class="section return"><dt>Returns</dt><dd>The buffer's reception time on the host, in ms. Not an absolute time value. </dd></dl>

</div>
</div>
<a class="anchor" id="acc3ec6d9aa3ce9175a55a9f268853e53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvBuffer::GetRedundantPacketCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of packets received more than once. </p>
<dl class="section return"><dt>Returns</dt><dd>The redundant packet count </dd></dl>

</div>
</div>
<a class="anchor" id="a5f9052f366299722a2b40a856edd9c51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvBuffer::GetRequiredSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the size of buffer required to hold the acquired block including, if present, additional chunk data and headers, padding. </p>
<dl class="section return"><dt>Returns</dt><dd>The size, in bytes, required to hold the block in this buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a6e0770ef8c08f8fb45c0143fe7899e66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvBuffer::GetResendGroupRequestedCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of resend requests issued by the data receiver. </p>
<dl class="section return"><dt>Returns</dt><dd>The resend requested count </dd></dl>

</div>
</div>
<a class="anchor" id="a8bf1e0a44fdea528a1f4eea3dd45520b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvBuffer::GetResendPacketRequestedCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of packets the data receiver requests with ResendGroupRequested. </p>
<dl class="section return"><dt>Returns</dt><dd>The received resend requested packet count </dd></dl>

</div>
</div>
<a class="anchor" id="a54c1bb97c5cb8b165de7fa4e033f5afa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvBuffer::GetSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the buffer's allocated or attached size (total capacity) in bytes. </p>
<dl class="section return"><dt>Returns</dt><dd>The buffer's (allocated or attached) size in bytes </dd></dl>

</div>
</div>
<a class="anchor" id="a03fdee47f9fed59c0e49f786afc5fb11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t PvBuffer::GetTimestamp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the buffer's timestamp. </p>
<dl class="section return"><dt>Returns</dt><dd>The buffer's hardware timestamp; For Pleora GigE Vision devices, this is the value of the <b>GevTimestampValue</b> when it began receiving data from the camera head (on the rising edge of the FVAL). </dd></dl>

</div>
</div>
<a class="anchor" id="a0af05140436fd443ce5abcf6a54832ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PvBuffer::HasChunks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the buffer has data chunks. </p>
<p>Unlike GetChunkCount, chunks do not need to be parsed or resolved with this method.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the buffer holds data chunks, false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="afb764127bb8864f866ef812cd2dc1e61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PvBuffer::IsExtendedID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the buffer is currently in extended ID mode. </p>
<p>When the extended ID mode is not enabled, the maximum block ID is 0xFFFFFF and the maximum packet ID is 0xFFFFFF as per the GEV 1.X specification. When the extended ID mode is enabled, the maximum block ID is 0xFFFFFFFFFFFFFFFF and the maximum packet ID is 0xFFFFFFFF as per the GEV 2.X specification.</p>
<p>When a <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> is received, the extended ID mode is initialized based on the information received by <a class="el" href="class_pv_stream.html" title="Receive data from a GigE Vision or USB3 Vision transmitter. ">PvStream</a>. When a <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> is sent, the extended ID mode will be initialized by the <a class="el" href="class_pv_transmitter_g_e_v.html#a69c8cf9d29815558782c3b9cebad93f1" title="Constructor. ">PvTransmitterGEV::PvTransmitterGEV</a> according to its configuration.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the extended if mode is in usage: </dd></dl>

</div>
</div>
<a class="anchor" id="afedeb78adc823aff996d5682f4fdeac0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PvBuffer::IsHeaderValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether this buffer has valid header (GVSP) information. </p>
<p>If the buffer header is not valid (missing) the buffer has to be manipulated with extreme caution. To start with, it is impossible to confirm the payload type. The timestamp and other shared header information is not valid. Finally, information specific to some payload types (like with, height, pixel format, etc. for the image payload type) is not available or valid this buffer.</p>
<p>When a buffer is attached or allocated for use other than receiving GVSP data, this attribute evaluates to true in order to appear as valid.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the GVSP header is valid. </dd></dl>

</div>
</div>
<a class="anchor" id="a3c7d71796bff6856871b1d6468a1f2df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PvBuffer::IsTrailerValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether this buffer has valid trailer (GVSP) information. </p>
<p>If the buffer trailer is not valid (missing) some information about the buffer could be missing. As an example, the image payload type confirms the number of lines received in the trailer.</p>
<p>When a buffer is attached or allocated for use other than receiving GVSP data, this attribute evaluates to true in order to appear as valid.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the GVSP header is valid. </dd></dl>

</div>
</div>
<a class="anchor" id="a1ec5abd18467aa4855a6ba46e22c6b02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvBuffer::Reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30f">PvPayloadType</a>&#160;</td>
          <td class="paramname"><em>aPayloadType</em> = <code><a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30faeb97a52f2036290b6213951f7782c841">PvPayloadTypeImage</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reconstruct the object with a new payload type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aPayloadType</td><td>The payload type to reset the buffer to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> if successful. </dd></dl>

</div>
</div>
<a class="anchor" id="acd62220f283c5b3c42444360390d2fdf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PvBuffer::SetID </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>aID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the buffer's ID. </p>
<p>The <a class="el" href="class_pv_buffer.html#acd62220f283c5b3c42444360390d2fdf" title="Set the buffer&#39;s ID. ">SetID</a> method lets you assign an arbitrary number to a buffer. When you retrieve the buffer later, you can also recover the number you assigned.</p>
<p>The ID is completely arbitrary and solely available for your own use. It can be useful to keep track of buffers in an application.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aID</td><td>The buffer's ID. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7359326b0c36f66f2a09f842d50186c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvBuffer::SetTimestamp </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>aTimestamp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the timestamp to place in the block leader. </p>
<p>When transmitting blocks to a GigE Vision receiver, by default, the timestamp on outgoing blocks is zero. However, the calling application may set a timestamp on the outgoing blocks if desired by calling <a class="el" href="class_pv_buffer.html#a7359326b0c36f66f2a09f842d50186c0" title="Set the timestamp to place in the block leader. ">SetTimestamp</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aTimestamp</td><td>The timestamp to set in the block leader</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> if successful. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_pv_buffer_8h_source.html">PvBuffer.h</a></li>
<li>PvBuffer.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr size="1">
<P><B>Copyright (c) 2002-2015 Pleora Technologies Inc.</B><BR>
<a href="http://www.pleora.com" target="_blank">www.pleora.com</a></P>
</body>
</html>

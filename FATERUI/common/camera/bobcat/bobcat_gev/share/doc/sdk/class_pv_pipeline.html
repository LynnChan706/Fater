<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
		<title>PvPipeline Class Reference</title>
		<link href="doxygen.css" rel="stylesheet" type="text/css">
		<link href="tabs.css" rel="stylesheet" type="text/css">
	</head>
	<body>
	<div class="contents">
		<div class="textblock">
			<h2><a href="http://www.pleora.com" target="_blank"><img src="logo.jpg" alt="Pleora Technologies Inc." align="middle" border="0"></a>
			eBUS SDK v4.1.4.3606 API</h2>
		</div>
	</div>
	<br>
	<br>
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_pv_pipeline.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_pv_pipeline-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PvPipeline Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Helper class for receiving data from a GigE Vision or USB3 Vision transmitter.  
 <a href="class_pv_pipeline.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad822fe3c20395d6a9349e2f6d1e9b472"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_pipeline.html#ad822fe3c20395d6a9349e2f6d1e9b472">PvPipeline</a> (<a class="el" href="class_pv_stream.html">PvStream</a> *aStream)</td></tr>
<tr class="memdesc:ad822fe3c20395d6a9349e2f6d1e9b472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#ad822fe3c20395d6a9349e2f6d1e9b472">More...</a><br/></td></tr>
<tr class="separator:ad822fe3c20395d6a9349e2f6d1e9b472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a478f07a194812b3337700c8e6a2abbc8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a478f07a194812b3337700c8e6a2abbc8"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_pipeline.html#a478f07a194812b3337700c8e6a2abbc8">~PvPipeline</a> ()</td></tr>
<tr class="memdesc:a478f07a194812b3337700c8e6a2abbc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor. <br/></td></tr>
<tr class="separator:a478f07a194812b3337700c8e6a2abbc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f9fea1d2213ceee18a240b359999213"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_pipeline.html#a4f9fea1d2213ceee18a240b359999213">GetBufferSize</a> () const </td></tr>
<tr class="memdesc:a4f9fea1d2213ceee18a240b359999213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size for all managed buffers in bytes.  <a href="#a4f9fea1d2213ceee18a240b359999213">More...</a><br/></td></tr>
<tr class="separator:a4f9fea1d2213ceee18a240b359999213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f9ce5fba766c64ced95ca2c3a0c0e3c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_pipeline.html#a5f9ce5fba766c64ced95ca2c3a0c0e3c">GetBufferCount</a> () const </td></tr>
<tr class="memdesc:a5f9ce5fba766c64ced95ca2c3a0c0e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of buffers owned and used by the pipeline.  <a href="#a5f9ce5fba766c64ced95ca2c3a0c0e3c">More...</a><br/></td></tr>
<tr class="separator:a5f9ce5fba766c64ced95ca2c3a0c0e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a966d6c72dcad53de6855081f11663008"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_pipeline.html#a966d6c72dcad53de6855081f11663008">GetOutputQueueSize</a> () const </td></tr>
<tr class="memdesc:a966d6c72dcad53de6855081f11663008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> objects currently available in the output queue.  <a href="#a966d6c72dcad53de6855081f11663008">More...</a><br/></td></tr>
<tr class="separator:a966d6c72dcad53de6855081f11663008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53554beeb0add411eaab690bed19c24"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_pipeline.html#aa53554beeb0add411eaab690bed19c24">GetHandleBufferTooSmall</a> () const </td></tr>
<tr class="memdesc:aa53554beeb0add411eaab690bed19c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the pipeline is configured to handle BUFFER_TOO_SMALL operation results automatically.  <a href="#aa53554beeb0add411eaab690bed19c24">More...</a><br/></td></tr>
<tr class="separator:aa53554beeb0add411eaab690bed19c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a264320654faccaf38c967c2bd5f30859"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_pipeline.html#a264320654faccaf38c967c2bd5f30859">IsStarted</a> ()</td></tr>
<tr class="memdesc:a264320654faccaf38c967c2bd5f30859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the pipeline has started.  <a href="#a264320654faccaf38c967c2bd5f30859">More...</a><br/></td></tr>
<tr class="separator:a264320654faccaf38c967c2bd5f30859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a2a34db8c9a5308ea9184da4219c18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_pipeline.html#a52a2a34db8c9a5308ea9184da4219c18">SetBufferSize</a> (uint32_t aSize)</td></tr>
<tr class="memdesc:a52a2a34db8c9a5308ea9184da4219c18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the optimal size of buffers being queued into the data receiver.  <a href="#a52a2a34db8c9a5308ea9184da4219c18">More...</a><br/></td></tr>
<tr class="separator:a52a2a34db8c9a5308ea9184da4219c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e55b4b86b8d8b5c89fd36fb55569426"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_pipeline.html#a5e55b4b86b8d8b5c89fd36fb55569426">SetBufferCount</a> (uint32_t aBufferCount)</td></tr>
<tr class="memdesc:a5e55b4b86b8d8b5c89fd36fb55569426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of buffers owned and used by the <a class="el" href="class_pv_pipeline.html" title="Helper class for receiving data from a GigE Vision or USB3 Vision transmitter. ">PvPipeline</a>.  <a href="#a5e55b4b86b8d8b5c89fd36fb55569426">More...</a><br/></td></tr>
<tr class="separator:a5e55b4b86b8d8b5c89fd36fb55569426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef46dab3376374f75d46bcf0f2401987"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_pipeline.html#aef46dab3376374f75d46bcf0f2401987">SetHandleBufferTooSmall</a> (bool aValue)</td></tr>
<tr class="memdesc:aef46dab3376374f75d46bcf0f2401987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures whether the pipeline handles BUFFER_TOO_SMALL operation result or not.  <a href="#aef46dab3376374f75d46bcf0f2401987">More...</a><br/></td></tr>
<tr class="separator:aef46dab3376374f75d46bcf0f2401987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1924fc80cff8d6c566f1429e0dc682f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_pipeline.html#aa1924fc80cff8d6c566f1429e0dc682f">RetrieveNextBuffer</a> (<a class="el" href="class_pv_buffer.html">PvBuffer</a> **aBuffer, uint32_t aTimeout=0xFFFFFFFF, PvResult *aOperationResult=NULL)</td></tr>
<tr class="memdesc:aa1924fc80cff8d6c566f1429e0dc682f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the next acquired block.  <a href="#aa1924fc80cff8d6c566f1429e0dc682f">More...</a><br/></td></tr>
<tr class="separator:aa1924fc80cff8d6c566f1429e0dc682f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a222611f32231e0c5621ec8e4c08e500e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_pipeline.html#a222611f32231e0c5621ec8e4c08e500e">ReleaseBuffer</a> (<a class="el" href="class_pv_buffer.html">PvBuffer</a> *aBuffer)</td></tr>
<tr class="memdesc:a222611f32231e0c5621ec8e4c08e500e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a buffer to the pipeline.  <a href="#a222611f32231e0c5621ec8e4c08e500e">More...</a><br/></td></tr>
<tr class="separator:a222611f32231e0c5621ec8e4c08e500e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45390afd4c26bdd03f7494b36983622b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_pipeline.html#a45390afd4c26bdd03f7494b36983622b">Start</a> ()</td></tr>
<tr class="memdesc:a45390afd4c26bdd03f7494b36983622b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the <a class="el" href="class_pv_pipeline.html" title="Helper class for receiving data from a GigE Vision or USB3 Vision transmitter. ">PvPipeline</a>.  <a href="#a45390afd4c26bdd03f7494b36983622b">More...</a><br/></td></tr>
<tr class="separator:a45390afd4c26bdd03f7494b36983622b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a39c6fc0a0f52cfaca39a0476b6c73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_pipeline.html#a63a39c6fc0a0f52cfaca39a0476b6c73">Stop</a> ()</td></tr>
<tr class="memdesc:a63a39c6fc0a0f52cfaca39a0476b6c73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the <a class="el" href="class_pv_pipeline.html" title="Helper class for receiving data from a GigE Vision or USB3 Vision transmitter. ">PvPipeline</a>.  <a href="#a63a39c6fc0a0f52cfaca39a0476b6c73">More...</a><br/></td></tr>
<tr class="separator:a63a39c6fc0a0f52cfaca39a0476b6c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47139a6583bbdbf55712b38b0979052c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_pipeline.html#a47139a6583bbdbf55712b38b0979052c">Reset</a> ()</td></tr>
<tr class="memdesc:a47139a6583bbdbf55712b38b0979052c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the pipeline.  <a href="#a47139a6583bbdbf55712b38b0979052c">More...</a><br/></td></tr>
<tr class="separator:a47139a6583bbdbf55712b38b0979052c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02b86367a85450f5c8250ea7da4a57ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_pipeline.html#a02b86367a85450f5c8250ea7da4a57ae">RegisterEventSink</a> (<a class="el" href="class_pv_pipeline_event_sink.html">PvPipelineEventSink</a> *aEventSink)</td></tr>
<tr class="memdesc:a02b86367a85450f5c8250ea7da4a57ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an event sink used for callbacks.  <a href="#a02b86367a85450f5c8250ea7da4a57ae">More...</a><br/></td></tr>
<tr class="separator:a02b86367a85450f5c8250ea7da4a57ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1845ba527ddc09564a319d1de9a9f44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_pipeline.html#af1845ba527ddc09564a319d1de9a9f44">UnregisterEventSink</a> (<a class="el" href="class_pv_pipeline_event_sink.html">PvPipelineEventSink</a> *aEventSink)</td></tr>
<tr class="memdesc:af1845ba527ddc09564a319d1de9a9f44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister an event sink.  <a href="#af1845ba527ddc09564a319d1de9a9f44">More...</a><br/></td></tr>
<tr class="separator:af1845ba527ddc09564a319d1de9a9f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d48e0ed16142230b0f470c6d65a3b8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_pipeline.html#a25d48e0ed16142230b0f470c6d65a3b8">GetBufferHandlingThreadPriority</a> () const </td></tr>
<tr class="memdesc:a25d48e0ed16142230b0f470c6d65a3b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the priority of the pipeline thread.  <a href="#a25d48e0ed16142230b0f470c6d65a3b8">More...</a><br/></td></tr>
<tr class="separator:a25d48e0ed16142230b0f470c6d65a3b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abee6125a1608074ad5a7b141ed58f52c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_pipeline.html#abee6125a1608074ad5a7b141ed58f52c">SetBufferHandlingThreadPriority</a> (uint32_t aPriority)</td></tr>
<tr class="memdesc:abee6125a1608074ad5a7b141ed58f52c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the priority of the pipeline thread.  <a href="#abee6125a1608074ad5a7b141ed58f52c">More...</a><br/></td></tr>
<tr class="separator:abee6125a1608074ad5a7b141ed58f52c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Helper class for receiving data from a GigE Vision or USB3 Vision transmitter. </p>
<p>The process of receiving data from a GigE Vision or USB3 Vision transmitter involves queuing buffers into the data receiver ensuring that there are always buffers available for the incoming data. <a class="el" href="class_pv_pipeline.html" title="Helper class for receiving data from a GigE Vision or USB3 Vision transmitter. ">PvPipeline</a> partners with a <a class="el" href="class_pv_stream.html" title="Receive data from a GigE Vision or USB3 Vision transmitter. ">PvStream</a> object to allocate and push buffers into the data receiver as needed.</p>
<p>For further information on how <a class="el" href="class_pv_pipeline.html" title="Helper class for receiving data from a GigE Vision or USB3 Vision transmitter. ">PvPipeline</a> fits in with the process of receiving data from a GigE Vision transmitter, refer to the <a href="receivingdata.html">receiving data from a transmitter</a> page. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad822fe3c20395d6a9349e2f6d1e9b472"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvPipeline::PvPipeline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pv_stream.html">PvStream</a> *&#160;</td>
          <td class="paramname"><em>aStream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>The <a class="el" href="class_pv_pipeline.html" title="Helper class for receiving data from a GigE Vision or USB3 Vision transmitter. ">PvPipeline</a> is just a helper of a <a class="el" href="class_pv_stream.html" title="Receive data from a GigE Vision or USB3 Vision transmitter. ">PvStream</a> class. Your code is still the owner of the <a class="el" href="class_pv_stream.html" title="Receive data from a GigE Vision or USB3 Vision transmitter. ">PvStream</a> class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aStream</td><td>The object responsible for receiving data from a GEV transmitter; a <a class="el" href="class_pv_stream.html" title="Receive data from a GigE Vision or USB3 Vision transmitter. ">PvStream</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a5f9ce5fba766c64ced95ca2c3a0c0e3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvPipeline::GetBufferCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get number of buffers owned and used by the pipeline. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of buffers. </dd></dl>

</div>
</div>
<a class="anchor" id="a25d48e0ed16142230b0f470c6d65a3b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvPipeline::GetBufferHandlingThreadPriority </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the priority of the pipeline thread. </p>
<p>See <a class="el" href="class_pv_pipeline.html#abee6125a1608074ad5a7b141ed58f52c" title="Set the priority of the pipeline thread. ">SetBufferHandlingThreadPriority</a> for details about the meaning of the values returned</p>
<dl class="section return"><dt>Returns</dt><dd>The priority of the thread </dd></dl>

</div>
</div>
<a class="anchor" id="a4f9fea1d2213ceee18a240b359999213"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvPipeline::GetBufferSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size for all managed buffers in bytes. </p>
<dl class="section return"><dt>Returns</dt><dd>The size of managed buffers, in bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="aa53554beeb0add411eaab690bed19c24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PvPipeline::GetHandleBufferTooSmall </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns if the pipeline is configured to handle BUFFER_TOO_SMALL operation results automatically. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the pipeline handles BUFFER_TOO_SMALL operation results automatically.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_pv_pipeline.html#aef46dab3376374f75d46bcf0f2401987" title="Configures whether the pipeline handles BUFFER_TOO_SMALL operation result or not. ...">PvPipeline::SetHandleBufferTooSmall</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a966d6c72dcad53de6855081f11663008"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvPipeline::GetOutputQueueSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> objects currently available in the output queue. </p>
<p><a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> objects are pushed into the output queue as soon as they have been populated with incoming data. <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> objects are pulled out of the output queue by calling <a class="el" href="class_pv_pipeline.html#aa1924fc80cff8d6c566f1429e0dc682f" title="Retrieve the next acquired block. ">RetrieveNextBuffer</a>. The number of buffers available in the pool managed by <a class="el" href="class_pv_pipeline.html" title="Helper class for receiving data from a GigE Vision or USB3 Vision transmitter. ">PvPipeline</a> is limited to <a class="el" href="class_pv_pipeline.html#a5f9ce5fba766c64ced95ca2c3a0c0e3c" title="Get number of buffers owned and used by the pipeline. ">GetBufferCount</a>. If the calling application cannot retrieve buffers at the rate that data is arriving, buffers are silently dropped. To obtain a count of dropped buffers, refer to the PipelineImagesDropped property of the <a class="el" href="class_pv_stream.html" title="Receive data from a GigE Vision or USB3 Vision transmitter. ">PvStream</a> parameters.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> currently available in the output queue. </dd></dl>

</div>
</div>
<a class="anchor" id="a264320654faccaf38c967c2bd5f30859"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PvPipeline::IsStarted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if the pipeline has started. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the pipeline has been started (using <a class="el" href="class_pv_pipeline.html#a45390afd4c26bdd03f7494b36983622b" title="Starts the PvPipeline. ">Start</a>); otherwise, false. </dd></dl>

</div>
</div>
<a class="anchor" id="a02b86367a85450f5c8250ea7da4a57ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvPipeline::RegisterEventSink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pv_pipeline_event_sink.html">PvPipelineEventSink</a> *&#160;</td>
          <td class="paramname"><em>aEventSink</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an event sink used for callbacks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aEventSink</td><td>A pointer to the event sink.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa01691a7ea2f9fd92fb720c5477bcda1">PvResult::Code::INVALID_PARAMETER</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caaea66673c270a1677db8b884d37681b6">PvResult::Code::GENERIC_ERROR</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a222611f32231e0c5621ec8e4c08e500e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvPipeline::ReleaseBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pv_buffer.html">PvBuffer</a> *&#160;</td>
          <td class="paramname"><em>aBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a buffer to the pipeline. </p>
<p><b>IMPORTANT</b>: all buffers retrieved through <a class="el" href="class_pv_pipeline.html#aa1924fc80cff8d6c566f1429e0dc682f" title="Retrieve the next acquired block. ">RetrieveNextBuffer</a> must be released back to the <a class="el" href="class_pv_pipeline.html" title="Helper class for receiving data from a GigE Vision or USB3 Vision transmitter. ">PvPipeline</a>. A minimum of 4 buffers must be available to the <a class="el" href="class_pv_pipeline.html" title="Helper class for receiving data from a GigE Vision or USB3 Vision transmitter. ">PvPipeline</a> at all times.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aBuffer</td><td>A pointer to the buffer to return to the queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html">PvResult::Code</a>:OK</li>
<li><a class="el" href="struct_pv_result_1_1_code.html">PvResult::Code</a>:NOT_ENOUGH_MEMORY (May occur if the buffer size needs to be increased but not enough memory is available.) </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a47139a6583bbdbf55712b38b0979052c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvPipeline::Reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the pipeline. </p>
<p>Synchronously aborts the stream, waits for all buffers to be removed from the stream and queues in a fresh set of buffers. Call ONLY when it is running, otherwise it returns error</p>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca20b763c2ece588805c271b68bccb9134">PvResult::Code::STATE_ERROR</a> If already waiting for another reset to complete or if not running </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aa1924fc80cff8d6c566f1429e0dc682f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvPipeline::RetrieveNextBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pv_buffer.html">PvBuffer</a> **&#160;</td>
          <td class="paramname"><em>aBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aTimeout</em> = <code>0xFFFFFFFF</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pv_result.html">PvResult</a> *&#160;</td>
          <td class="paramname"><em>aOperationResult</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the next acquired block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">aBuffer</td><td>A pointer to the pointer to the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aTimeout</td><td>The maximum time, in ms, to wait for a buffer to be received. The default value (0xFFFFFFFF) uses the stream object's timeout (For <a class="el" href="class_pv_stream.html" title="Receive data from a GigE Vision or USB3 Vision transmitter. ">PvStream</a>, the parameter is DefaultImageTimeout. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aOperationResult</td><td>A pointer to the result of the acquisition operation on aBuffer, see <a class="el" href="class_pv_buffer.html#ab6089cf8573309e856216d0700beecca" title="Returns the value of aOperationResult when this buffer was last received through a PvStream...">PvBuffer::GetOperationResult</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca8044711331afcc8f9607defdeb4f897f">PvResult::Code::TIMEOUT</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa01691a7ea2f9fd92fb720c5477bcda1">PvResult::Code::INVALID_PARAMETER</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caf0c5724f089cdd8da32b184bc52f891f">PvResult::Code::NOT_CONNECTED</a> -&gt; not connected</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7cad33ef0f5a66d0a4b30be5b52146dea7d">PvResult::Code::NO_MORE_ITEM</a> -&gt; no <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> queued </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a5e55b4b86b8d8b5c89fd36fb55569426"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvPipeline::SetBufferCount </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aBufferCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the number of buffers owned and used by the <a class="el" href="class_pv_pipeline.html" title="Helper class for receiving data from a GigE Vision or USB3 Vision transmitter. ">PvPipeline</a>. </p>
<p>Buffers are added or removed as necessary until the actual buffer count matches the desired buffer count being set. During this time, the pipeline is paused temporarily.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aBufferCount</td><td>The total number of buffers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7cac194e39fb420655ac75525f53714bc2c">PvResult::Code::NOT_ENOUGH_MEMORY</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa01691a7ea2f9fd92fb720c5477bcda1">PvResult::Code::INVALID_PARAMETER</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="abee6125a1608074ad5a7b141ed58f52c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvPipeline::SetBufferHandlingThreadPriority </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aPriority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the priority of the pipeline thread. </p>
<p>This thread is pretty much the pipeline itself: it queues buffers in <a class="el" href="class_pv_stream.html" title="Receive data from a GigE Vision or USB3 Vision transmitter. ">PvStream</a> and retrieves them when they are ready, making them available in an output queue.</p>
<p>In Linux, the priorities supported are between 0 and 99, 99 been the highest priority as per the SCHED_FIFO scheduler specifications. If the process is not running with root priviledge, all the threads are run into the SCHED_OTHER ( scheduler 01 ) and have the same priority at 0.</p>
<p>In Windows, the priorities supported are between 0 and 6. The value will be translated into one of the following scheduler defines: 0 - THREAD_PRIORITY_IDLE 1 - THREAD_PRIORITY_LOWEST 2 - THREAD_PRIORITY_BELOW_NORMAL 3 - THREAD_PRIORITY_NORMAL 4 - THREAD_PRIORITY_ABOVE_NORMAL 5 - THREAD_PRIORITY_HIGHEST 6 - THREAD_PRIORITY_TIME_CRITICAL</p>
<p>If you change the thread priorities, it may alterate the stability of the system. For this reason, if you report a bug to Pleora, ensure to clearly mention that you change threads priorities.</p>
<p>See <a class="el" href="class_pv_pipeline.html#a25d48e0ed16142230b0f470c6d65a3b8" title="Get the priority of the pipeline thread. ">GetBufferHandlingThreadPriority</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aPriority</td><td>Priority to be set to the conversion threads.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa01691a7ea2f9fd92fb720c5477bcda1">PvResult::Code::INVALID_PARAMETER</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca75e1d2230eff41caaf8074951249d63c">PvResult::Code::THREAD_ERROR</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a52a2a34db8c9a5308ea9184da4219c18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PvPipeline::SetBufferSize </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the optimal size of buffers being queued into the data receiver. </p>
<p>Each time a buffer is queued into the data receiver, it is re-allocated as necessary according to the following behavior:</p>
<ul>
<li>If the buffer size is less than the require buffer size (BUFFER_TOO_SMALL) it is re-allocated.</li>
<li>If the buffer size is more than four times the required buffer size, it is re-allocated in order to save memory.</li>
</ul>
<p>Originally the buffer size can be specified using SetBufferSize. The pipeline automatically adjusts the buffer size based on incoming buffers. As buffers are returned to the pipeline and being queued by the data receiver they may be re-allocated as described above.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aSize</td><td>The size of the buffer, in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_pv_buffer.html#ae29ff9092536ed20f600b53d151df653" title="Allocates memory for this PvBuffer. ">PvBuffer::Alloc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aef46dab3376374f75d46bcf0f2401987"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PvPipeline::SetHandleBufferTooSmall </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>aValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures whether the pipeline handles BUFFER_TOO_SMALL operation result or not. </p>
<p>If the pipeline is configured to handle BUFFER_TOO_SMALL operation results the buffers are automatically re-allocated and re-queued for acquisition when this condition occurs.</p>
<p>If the pipeline is not configured to handled BUFFER_TOO_SMALL operation results the buffers are queued in the pipeline output queue just as any other buffer and what to do with the buffer is deferred to the application using <a class="el" href="class_pv_pipeline.html" title="Helper class for receiving data from a GigE Vision or USB3 Vision transmitter. ">PvPipeline</a>.</p>
<p>If the pipeline handles BUFFER_TOO_SMALL operation results, the <a class="el" href="class_pv_pipeline_event_sink.html#a9a8cf195145963102bb6e20ebfa29f52" title="PvPipeline event sink OnBufferTooSmall event. ">PvPipelineEventSink::OnBufferTooSmall</a> callback is invoked in order to order to query how to handle the condition. If not implemented the default behaviour is applied. See <a class="el" href="class_pv_pipeline_event_sink.html#a9a8cf195145963102bb6e20ebfa29f52" title="PvPipeline event sink OnBufferTooSmall event. ">PvPipelineEventSink::OnBufferTooSmall</a> for more information.</p>
<p><a class="el" href="class_pv_pipeline_event_sink.html#a9a8cf195145963102bb6e20ebfa29f52" title="PvPipeline event sink OnBufferTooSmall event. ">PvPipelineEventSink::OnBufferTooSmall</a> is not invoked when the pipeline is not configured to handle BUFFER_TOO_SMALL operation results.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aValue</td><td>If true, the pipeline handles BUFFER_TOO_SMALL operation results automatically. If false the pipeline queues these buffers in the output queue and defers handling of these buffers to the application. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a45390afd4c26bdd03f7494b36983622b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvPipeline::Start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts the <a class="el" href="class_pv_pipeline.html" title="Helper class for receiving data from a GigE Vision or USB3 Vision transmitter. ">PvPipeline</a>. </p>
<p>In order to retrieve images from the stream and make them available to <a class="el" href="class_pv_pipeline.html#aa1924fc80cff8d6c566f1429e0dc682f" title="Retrieve the next acquired block. ">RetrieveNextBuffer</a>, the pipeline must be running. This starts a thread that continually ensures that buffers are allocated and ready in the <a class="el" href="class_pv_stream.html" title="Receive data from a GigE Vision or USB3 Vision transmitter. ">PvStream</a> so that incoming data is captured.</p>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a63a39c6fc0a0f52cfaca39a0476b6c73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvPipeline::Stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops the <a class="el" href="class_pv_pipeline.html" title="Helper class for receiving data from a GigE Vision or USB3 Vision transmitter. ">PvPipeline</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caaea66673c270a1677db8b884d37681b6">PvResult::Code::GENERIC_ERROR</a> (Errors occured when stopping the pipeline's thread.) </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="af1845ba527ddc09564a319d1de9a9f44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvPipeline::UnregisterEventSink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pv_pipeline_event_sink.html">PvPipelineEventSink</a> *&#160;</td>
          <td class="paramname"><em>aEventSink</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister an event sink. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aEventSink</td><td>A pointer to the event sink.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa01691a7ea2f9fd92fb720c5477bcda1">PvResult::Code::INVALID_PARAMETER</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa4357271e02951867594e0cc932c12f8">PvResult::Code::NOT_FOUND</a> </li>
</ul>
</dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_pv_pipeline_8h_source.html">PvPipeline.h</a></li>
<li>PvPipeline.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr size="1">
<P><B>Copyright (c) 2002-2015 Pleora Technologies Inc.</B><BR>
<a href="http://www.pleora.com" target="_blank">www.pleora.com</a></P>
</body>
</html>

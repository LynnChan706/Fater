<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
		<title>PvStream Class Reference</title>
		<link href="doxygen.css" rel="stylesheet" type="text/css">
		<link href="tabs.css" rel="stylesheet" type="text/css">
	</head>
	<body>
	<div class="contents">
		<div class="textblock">
			<h2><a href="http://www.pleora.com" target="_blank"><img src="logo.jpg" alt="Pleora Technologies Inc." align="middle" border="0"></a>
			eBUS SDK v4.1.4.3606 API</h2>
		</div>
	</div>
	<br>
	<br>
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_pv_stream.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_pv_stream-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PvStream Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Receive data from a GigE Vision or USB3 Vision transmitter.  
 <a href="class_pv_stream.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a71f28d73993b4d0b4eee7b053b266fb2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71f28d73993b4d0b4eee7b053b266fb2"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_stream.html#a71f28d73993b4d0b4eee7b053b266fb2">~PvStream</a> ()</td></tr>
<tr class="memdesc:a71f28d73993b4d0b4eee7b053b266fb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="separator:a71f28d73993b4d0b4eee7b053b266fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719aa036dbc4dc95373ff6a91ae4aa2b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_stream.html#a719aa036dbc4dc95373ff6a91ae4aa2b">GetQueuedBufferCount</a> () const </td></tr>
<tr class="memdesc:a719aa036dbc4dc95373ff6a91ae4aa2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of buffers (<a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> objects) waiting to be filled with images by the data receiver.  <a href="#a719aa036dbc4dc95373ff6a91ae4aa2b">More...</a><br/></td></tr>
<tr class="separator:a719aa036dbc4dc95373ff6a91ae4aa2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d678390f04f2fba8f1ff050704aed71"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_stream.html#a3d678390f04f2fba8f1ff050704aed71">GetQueuedBufferMaximum</a> () const </td></tr>
<tr class="memdesc:a3d678390f04f2fba8f1ff050704aed71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum number of buffers (<a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> objects) that can be queued at a time.  <a href="#a3d678390f04f2fba8f1ff050704aed71">More...</a><br/></td></tr>
<tr class="separator:a3d678390f04f2fba8f1ff050704aed71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3cac127608f65dc98cf0647cc31b770"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_stream.html#ab3cac127608f65dc98cf0647cc31b770">Close</a> ()</td></tr>
<tr class="memdesc:ab3cac127608f65dc98cf0647cc31b770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the stream channel receiver.  <a href="#ab3cac127608f65dc98cf0647cc31b770">More...</a><br/></td></tr>
<tr class="separator:ab3cac127608f65dc98cf0647cc31b770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f766192dae3175c0829723f429f73d9"><td class="memItemLeft" align="right" valign="top">PvStreamType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_stream.html#a4f766192dae3175c0829723f429f73d9">GetType</a> () const </td></tr>
<tr class="memdesc:a4f766192dae3175c0829723f429f73d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the object is a GigE Vision or USB3 Vision stream receiver.  <a href="#a4f766192dae3175c0829723f429f73d9">More...</a><br/></td></tr>
<tr class="separator:a4f766192dae3175c0829723f429f73d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09078df78c43976d2cf36abc5de3e743"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_stream.html#a09078df78c43976d2cf36abc5de3e743">AbortQueuedBuffers</a> ()</td></tr>
<tr class="memdesc:a09078df78c43976d2cf36abc5de3e743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abort all pending block requests.  <a href="#a09078df78c43976d2cf36abc5de3e743">More...</a><br/></td></tr>
<tr class="separator:a09078df78c43976d2cf36abc5de3e743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e3ee604eed8e2cbadf2b2cdca5f3948"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_stream.html#a8e3ee604eed8e2cbadf2b2cdca5f3948">QueueBuffer</a> (<a class="el" href="class_pv_buffer.html">PvBuffer</a> *aBuffer)</td></tr>
<tr class="memdesc:a8e3ee604eed8e2cbadf2b2cdca5f3948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue a buffer to receive a block.  <a href="#a8e3ee604eed8e2cbadf2b2cdca5f3948">More...</a><br/></td></tr>
<tr class="separator:a8e3ee604eed8e2cbadf2b2cdca5f3948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bcce3d5c1f0b35e1db259fa82640e40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_stream.html#a8bcce3d5c1f0b35e1db259fa82640e40">RetrieveBuffer</a> (<a class="el" href="class_pv_buffer.html">PvBuffer</a> **aBuffer, <a class="el" href="class_pv_result.html">PvResult</a> *aOperationResult, uint32_t aTimeout=0xFFFFFFFF)</td></tr>
<tr class="memdesc:a8bcce3d5c1f0b35e1db259fa82640e40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to retrieve a queued buffer.  <a href="#a8bcce3d5c1f0b35e1db259fa82640e40">More...</a><br/></td></tr>
<tr class="separator:a8bcce3d5c1f0b35e1db259fa82640e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730b3f2610bdae08d9a6e95d535f7cba"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_stream.html#a730b3f2610bdae08d9a6e95d535f7cba">GetChannel</a> ()</td></tr>
<tr class="memdesc:a730b3f2610bdae08d9a6e95d535f7cba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the stream's Channel property.  <a href="#a730b3f2610bdae08d9a6e95d535f7cba">More...</a><br/></td></tr>
<tr class="separator:a730b3f2610bdae08d9a6e95d535f7cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab16f00f857fb46e738b0fae1fc78548e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_stream.html#ab16f00f857fb46e738b0fae1fc78548e">IsOpen</a> () const </td></tr>
<tr class="memdesc:ab16f00f857fb46e738b0fae1fc78548e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the stream is open.  <a href="#ab16f00f857fb46e738b0fae1fc78548e">More...</a><br/></td></tr>
<tr class="separator:ab16f00f857fb46e738b0fae1fc78548e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd55f284e142ac8feb31e81da7158f08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_stream.html#acd55f284e142ac8feb31e81da7158f08">RegisterEventSink</a> (<a class="el" href="class_pv_stream_event_sink.html">PvStreamEventSink</a> *aEventSink)</td></tr>
<tr class="memdesc:acd55f284e142ac8feb31e81da7158f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an event sink used for callbacks.  <a href="#acd55f284e142ac8feb31e81da7158f08">More...</a><br/></td></tr>
<tr class="separator:acd55f284e142ac8feb31e81da7158f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff80ee1da32b5efa381efa48bc9c6752"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_stream.html#aff80ee1da32b5efa381efa48bc9c6752">UnregisterEventSink</a> (<a class="el" href="class_pv_stream_event_sink.html">PvStreamEventSink</a> *aEventSink)</td></tr>
<tr class="memdesc:aff80ee1da32b5efa381efa48bc9c6752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister an event sink.  <a href="#aff80ee1da32b5efa381efa48bc9c6752">More...</a><br/></td></tr>
<tr class="separator:aff80ee1da32b5efa381efa48bc9c6752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39ad5080f439692a622ea517022f94f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_gen_parameter_array.html">PvGenParameterArray</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_stream.html#ab39ad5080f439692a622ea517022f94f">GetParameters</a> ()</td></tr>
<tr class="memdesc:ab39ad5080f439692a622ea517022f94f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the parameters defining how data is received from a GigE Vision transmitter.  <a href="#ab39ad5080f439692a622ea517022f94f">More...</a><br/></td></tr>
<tr class="separator:ab39ad5080f439692a622ea517022f94f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a368c9e7de311de5bf204489c8b778303"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_pv_stream.html">PvStream</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_stream.html#a368c9e7de311de5bf204489c8b778303">CreateAndOpen</a> (const <a class="el" href="class_pv_string.html">PvString</a> &amp;aInfo, <a class="el" href="class_pv_result.html">PvResult</a> *aResult)</td></tr>
<tr class="memdesc:a368c9e7de311de5bf204489c8b778303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamically allocates a <a class="el" href="class_pv_stream.html" title="Receive data from a GigE Vision or USB3 Vision transmitter. ">PvStream</a> of the right type.  <a href="#a368c9e7de311de5bf204489c8b778303">More...</a><br/></td></tr>
<tr class="separator:a368c9e7de311de5bf204489c8b778303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd929a80f46aa954b8de08bfbc57fd4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_stream.html#adfd929a80f46aa954b8de08bfbc57fd4">Free</a> (<a class="el" href="class_pv_stream.html">PvStream</a> *aStream)</td></tr>
<tr class="memdesc:adfd929a80f46aa954b8de08bfbc57fd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees an object allocated with CreateAndOpen.  <a href="#adfd929a80f46aa954b8de08bfbc57fd4">More...</a><br/></td></tr>
<tr class="separator:adfd929a80f46aa954b8de08bfbc57fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a147411ee27d1bac1be467ae433b4ca50"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a147411ee27d1bac1be467ae433b4ca50"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_stream.html#a147411ee27d1bac1be467ae433b4ca50">PvStream</a> ()</td></tr>
<tr class="memdesc:a147411ee27d1bac1be467ae433b4ca50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br/></td></tr>
<tr class="separator:a147411ee27d1bac1be467ae433b4ca50"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:afbebe17463fe09a03e19c5ac67193db8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afbebe17463fe09a03e19c5ac67193db8"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>PvPipeline</b></td></tr>
<tr class="separator:afbebe17463fe09a03e19c5ac67193db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac517f739d9d345b2cb5f6bfdf7ad9aa3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac517f739d9d345b2cb5f6bfdf7ad9aa3"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>PvConfigurationWriter</b></td></tr>
<tr class="separator:ac517f739d9d345b2cb5f6bfdf7ad9aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a304b6733d7b057c958e051fcea83789c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a304b6733d7b057c958e051fcea83789c"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>PvConfigurationReader</b></td></tr>
<tr class="separator:a304b6733d7b057c958e051fcea83789c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Receive data from a GigE Vision or USB3 Vision transmitter. </p>
<p>This provides a means of opening a connection to the data receiver and obtaining data from it. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a09078df78c43976d2cf36abc5de3e743"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvStream::AbortQueuedBuffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abort all pending block requests. </p>
<p>Once you've aborted pending block requests, they still need to be de-queued. Use <a class="el" href="class_pv_stream.html#a8bcce3d5c1f0b35e1db259fa82640e40" title="Attempt to retrieve a queued buffer. ">RetrieveBuffer</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caf0c5724f089cdd8da32b184bc52f891f">PvResult::Code::NOT_CONNECTED</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ab3cac127608f65dc98cf0647cc31b770"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvStream::Close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close the stream channel receiver. </p>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caf0c5724f089cdd8da32b184bc52f891f">PvResult::Code::NOT_CONNECTED</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>Open </dd></dl>

</div>
</div>
<a class="anchor" id="a368c9e7de311de5bf204489c8b778303"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_stream.html">PvStream</a> * PvStream::CreateAndOpen </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_pv_string.html">PvString</a> &amp;&#160;</td>
          <td class="paramname"><em>aInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pv_result.html">PvResult</a> *&#160;</td>
          <td class="paramname"><em>aResult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dynamically allocates a <a class="el" href="class_pv_stream.html" title="Receive data from a GigE Vision or USB3 Vision transmitter. ">PvStream</a> of the right type. </p>
<p>This static method takes a string and creates the right type of <a class="el" href="class_pv_stream.html" title="Receive data from a GigE Vision or USB3 Vision transmitter. ">PvStream</a> (<a class="el" href="class_pv_stream_g_e_v.html" title="Receive data from a GigE Vision. ">PvStreamGEV</a> or <a class="el" href="class_pv_stream_u3_v.html" title="Receive data from a USB3 Vision transmitter. ">PvStreamU3V</a>) and connects it.</p>
<p>Objects allocated with CreateAndOpen should be freed with <a class="el" href="class_pv_stream.html#adfd929a80f46aa954b8de08bfbc57fd4" title="Frees an object allocated with CreateAndOpen. ">PvStream::Free</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aInfo</td><td>Information that uniquely identifies the device. You may use one of the following:<ul>
<li>GigE Vision device's IP Address. Use the form <code>192.168.1.114</code>.</li>
<li>USB3 Vision GUID. </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aResult</td><td>Outcome of the operation. Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa01691a7ea2f9fd92fb720c5477bcda1">PvResult::Code::INVALID_PARAMETER</a> aInfo is not correct or default buffer configurations are not correct</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7cac194e39fb420655ac75525f53714bc2c">PvResult::Code::NOT_ENOUGH_MEMORY</a> could not allocate class</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caf0c5724f089cdd8da32b184bc52f891f">PvResult::Code::NOT_CONNECTED</a> device not connected</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caaea66673c270a1677db8b884d37681b6">PvResult::Code::GENERIC_ERROR</a> unexpected drive error</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca7530ed7b45fcce742d7d82c9fa542edb">PvResult::Code::BAD_VERSION</a> bad driver version</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa4357271e02951867594e0cc932c12f8">PvResult::Code::NOT_FOUND</a> usb only</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca913655a6b3b2c251e9e04e5ea1ab8a10">PvResult::Code::CANNOT_OPEN_FILE</a> usb only</li>
<li>#PvREsult::Code::NOT_SUPPORTED usb only</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the new object on success, NULL on failure. See aResult for more information on the failure (unless failure was aResult being NULL) </dd></dl>

</div>
</div>
<a class="anchor" id="adfd929a80f46aa954b8de08bfbc57fd4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PvStream::Free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pv_stream.html">PvStream</a> *&#160;</td>
          <td class="paramname"><em>aStream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees an object allocated with CreateAndOpen. </p>
<p>Even though calling delete on a <a class="el" href="class_pv_stream.html" title="Receive data from a GigE Vision or USB3 Vision transmitter. ">PvStream</a> created with CreateAndOpen should work in most cases, sometime it is necessary to call "delete" in the same context where "new" was called to avoid false positives on memory leaks.</p>
<p>It is a good practice to use this method to free a <a class="el" href="class_pv_stream.html" title="Receive data from a GigE Vision or USB3 Vision transmitter. ">PvStream</a> allocated with CreateAndOpen.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aStream</td><td>Pointer to the device object to delete. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a730b3f2610bdae08d9a6e95d535f7cba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t PvStream::GetChannel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the stream's Channel property. </p>
<dl class="section return"><dt>Returns</dt><dd>The stream's Channel property. </dd></dl>

</div>
</div>
<a class="anchor" id="ab39ad5080f439692a622ea517022f94f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_gen_parameter_array.html">PvGenParameterArray</a> * PvStream::GetParameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the parameters defining how data is received from a GigE Vision transmitter. </p>
<dl class="section return"><dt>Returns</dt><dd>The parameters defining how data is received from a GigE Vision transmitter </dd></dl>

</div>
</div>
<a class="anchor" id="a719aa036dbc4dc95373ff6a91ae4aa2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvStream::GetQueuedBufferCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of buffers (<a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> objects) waiting to be filled with images by the data receiver. </p>
<p>Every call to <a class="el" href="class_pv_stream.html#a8e3ee604eed8e2cbadf2b2cdca5f3948" title="Queue a buffer to receive a block. ">QueueBuffer</a> increases the count by one; every call to <a class="el" href="class_pv_stream.html#a8bcce3d5c1f0b35e1db259fa82640e40" title="Attempt to retrieve a queued buffer. ">RetrieveBuffer</a> reduces the count by one.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of buffers (<a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> objects). </dd></dl>

</div>
</div>
<a class="anchor" id="a3d678390f04f2fba8f1ff050704aed71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvStream::GetQueuedBufferMaximum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum number of buffers (<a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> objects) that can be queued at a time. </p>
<dl class="section return"><dt>Returns</dt><dd>Maximum number of buffers (<a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> objects). </dd></dl>

</div>
</div>
<a class="anchor" id="a4f766192dae3175c0829723f429f73d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PvStreamType PvStream::GetType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the object is a GigE Vision or USB3 Vision stream receiver. </p>
<dl class="section return"><dt>Returns</dt><dd>Specific object type. </dd></dl>

</div>
</div>
<a class="anchor" id="ab16f00f857fb46e738b0fae1fc78548e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PvStream::IsOpen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if the stream is open. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the stream is opened; otherwise, false. </dd></dl>

</div>
</div>
<a class="anchor" id="a8e3ee604eed8e2cbadf2b2cdca5f3948"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvStream::QueueBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pv_buffer.html">PvBuffer</a> *&#160;</td>
          <td class="paramname"><em>aBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queue a buffer to receive a block. </p>
<p>The <a class="el" href="class_pv_stream.html#a8e3ee604eed8e2cbadf2b2cdca5f3948" title="Queue a buffer to receive a block. ">QueueBuffer</a> method queues in a buffer (<a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> object) to a stream (<a class="el" href="class_pv_stream.html" title="Receive data from a GigE Vision or USB3 Vision transmitter. ">PvStream</a> object) so it can be filled by the data receiver.</p>
<p>For each buffer you remove (using <a class="el" href="class_pv_stream.html#a8bcce3d5c1f0b35e1db259fa82640e40" title="Attempt to retrieve a queued buffer. ">RetrieveBuffer</a>), you should queue another (using <a class="el" href="class_pv_stream.html#a8e3ee604eed8e2cbadf2b2cdca5f3948" title="Queue a buffer to receive a block. ">QueueBuffer</a>). <b>The maximum number of buffers that can be queued at a given time can be obtained by calling <a class="el" href="class_pv_stream.html#a3d678390f04f2fba8f1ff050704aed71" title="Get the maximum number of buffers (PvBuffer objects) that can be queued at a time. ">GetQueuedBufferMaximum</a>.</b> To reduce the risk of missing incoming data, it is recommended that several blocks remain queued and ready to go at any given time. Generally it is recommended that a larger number of buffers remain queued for higher frame rates. Larger block sizes with blocks being streamed at a lower frame rate can afford to allocate fewer buffers to optimize memory usage and reduce potential latency.</p>
<p>Once the stream fills the buffer with a block, retrieve the buffer by calling <a class="el" href="class_pv_stream.html#a8bcce3d5c1f0b35e1db259fa82640e40" title="Attempt to retrieve a queued buffer. ">RetrieveBuffer</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aBuffer</td><td>A pointer to the buffer to be filled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa01691a7ea2f9fd92fb720c5477bcda1">PvResult::Code::INVALID_PARAMETER</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caf0c5724f089cdd8da32b184bc52f891f">PvResult::Code::NOT_CONNECTED</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca38362c4651c76a555152eb06137fbd2e">PvResult::Code::NO_MORE_ENTRY</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7cac194e39fb420655ac75525f53714bc2c">PvResult::Code::NOT_ENOUGH_MEMORY</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca243bf1f15a65a48672b6a2916359951a">PvResult::Code::PENDING</a> if the buffer has been properly queued</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caaea66673c270a1677db8b884d37681b6">PvResult::Code::GENERIC_ERROR</a> if the buffer could not be queued. See <a class="el" href="class_pv_result.html#aa6453a3e5111bc6c2b86fa3649216f85" title="Get the result description. ">PvResult::GetDescription</a> for more information </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="acd55f284e142ac8feb31e81da7158f08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvStream::RegisterEventSink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pv_stream_event_sink.html">PvStreamEventSink</a> *&#160;</td>
          <td class="paramname"><em>aEventSink</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an event sink used for callbacks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aEventSink</td><td>A pointer to the event sink.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa01691a7ea2f9fd92fb720c5477bcda1">PvResult::Code::INVALID_PARAMETER</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caaea66673c270a1677db8b884d37681b6">PvResult::Code::GENERIC_ERROR</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a8bcce3d5c1f0b35e1db259fa82640e40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvStream::RetrieveBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pv_buffer.html">PvBuffer</a> **&#160;</td>
          <td class="paramname"><em>aBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pv_result.html">PvResult</a> *&#160;</td>
          <td class="paramname"><em>aOperationResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aTimeout</em> = <code>0xFFFFFFFF</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to retrieve a queued buffer. </p>
<p>To use this method, see also <a class="el" href="class_pv_stream.html#a8e3ee604eed8e2cbadf2b2cdca5f3948" title="Queue a buffer to receive a block. ">QueueBuffer</a>.</p>
<p>The <a class="el" href="class_pv_stream.html#a8bcce3d5c1f0b35e1db259fa82640e40" title="Attempt to retrieve a queued buffer. ">RetrieveBuffer</a> method blocks until one of the following occurs:</p>
<ul>
<li>The buffer is filled with a block (image or raw data).</li>
<li>The retrieve buffer operation times out: it exceeds <em>aTimeout</em>.</li>
<li>The acquisition fails (by being aborted, data receiver timeout as defined by ImageTimeout property, etc.)</li>
</ul>
<p>Once the method returns, you can determine the ultimate success of the image acquisition by testing the <em>aOperationResult</em> parameter. For example, <a class="el" href="class_pv_stream.html#a8bcce3d5c1f0b35e1db259fa82640e40" title="Attempt to retrieve a queued buffer. ">RetrieveBuffer</a> may return <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a>, even if the operation was aborted (by a call to <a class="el" href="class_pv_stream.html#a09078df78c43976d2cf36abc5de3e743" title="Abort all pending block requests. ">AbortQueuedBuffers</a> or <a class="el" href="class_pv_stream.html#ab3cac127608f65dc98cf0647cc31b770" title="Close the stream channel receiver. ">Close</a>). In this case, <em>aOperationResult</em> would be <a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca02e7e13232d736f9215df059aa92280f">PvResult::Code::ABORTED</a>.</p>
<p>The return value contains the RetrieveBuffer operation results and <em>aOperationResult</em> contains the actual result (or failure) of the data receiver on this buffer. This method can succeed in providing you the oldest buffer but the result of the operation may still be a failure - if acquisition was aborted, incomplete, etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">aBuffer</td><td>The buffer that holds the image. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aOperationResult</td><td>A pointer to the result of the acquisition operation on aBuffer, see <a class="el" href="class_pv_buffer.html#ab6089cf8573309e856216d0700beecca" title="Returns the value of aOperationResult when this buffer was last received through a PvStream...">PvBuffer::GetOperationResult</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aTimeout</td><td>The maximum time, in ms, to wait for a buffer to be returned by the data receiver.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa01691a7ea2f9fd92fb720c5477bcda1">PvResult::Code::INVALID_PARAMETER</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca8044711331afcc8f9607defdeb4f897f">PvResult::Code::TIMEOUT</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caf0c5724f089cdd8da32b184bc52f891f">PvResult::Code::NOT_CONNECTED</a> (not connected.)</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca38362c4651c76a555152eb06137fbd2e">PvResult::Code::NO_MORE_ENTRY</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca8044711331afcc8f9607defdeb4f897f">PvResult::Code::TIMEOUT</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7cad33ef0f5a66d0a4b30be5b52146dea7d">PvResult::Code::NO_MORE_ITEM</a> (no <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> queued.)</li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7cacd9aca205059c59969e31adaaec0e505">PvResult::Code::BUSY</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aff80ee1da32b5efa381efa48bc9c6752"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvStream::UnregisterEventSink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pv_stream_event_sink.html">PvStreamEventSink</a> *&#160;</td>
          <td class="paramname"><em>aEventSink</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister an event sink. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aEventSink</td><td>A pointer to the event sink.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa01691a7ea2f9fd92fb720c5477bcda1">PvResult::Code::INVALID_PARAMETER</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa4357271e02951867594e0cc932c12f8">PvResult::Code::NOT_FOUND</a></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_pv_stream.html#acd55f284e142ac8feb31e81da7158f08" title="Register an event sink used for callbacks. ">RegisterEventSink</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_pv_stream_8h_source.html">PvStream.h</a></li>
<li>PvStream.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr size="1">
<P><B>Copyright (c) 2002-2015 Pleora Technologies Inc.</B><BR>
<a href="http://www.pleora.com" target="_blank">www.pleora.com</a></P>
</body>
</html>

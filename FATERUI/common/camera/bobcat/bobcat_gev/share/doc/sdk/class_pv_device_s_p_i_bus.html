<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
		<title>PvDeviceSPIBus Class Reference</title>
		<link href="doxygen.css" rel="stylesheet" type="text/css">
		<link href="tabs.css" rel="stylesheet" type="text/css">
	</head>
	<body>
	<div class="contents">
		<div class="textblock">
			<h2><a href="http://www.pleora.com" target="_blank"><img src="logo.jpg" alt="Pleora Technologies Inc." align="middle" border="0"></a>
			eBUS SDK v4.1.4.3606 API</h2>
		</div>
	</div>
	<br>
	<br>
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_pv_device_s_p_i_bus.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_pv_device_s_p_i_bus-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PvDeviceSPIBus Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>SPI serial controller.  
 <a href="class_pv_device_s_p_i_bus.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3f4b3e5fffa20f3d9e2da5caccaf2f24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f4b3e5fffa20f3d9e2da5caccaf2f24"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_device_s_p_i_bus.html#a3f4b3e5fffa20f3d9e2da5caccaf2f24">PvDeviceSPIBus</a> ()</td></tr>
<tr class="memdesc:a3f4b3e5fffa20f3d9e2da5caccaf2f24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br/></td></tr>
<tr class="separator:a3f4b3e5fffa20f3d9e2da5caccaf2f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044b861e666d5762bcc9d742da230a41"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a044b861e666d5762bcc9d742da230a41"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_device_s_p_i_bus.html#a044b861e666d5762bcc9d742da230a41">~PvDeviceSPIBus</a> ()</td></tr>
<tr class="memdesc:a044b861e666d5762bcc9d742da230a41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="separator:a044b861e666d5762bcc9d742da230a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9409b30b42eee3a5ada64fd35104ee36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_device_s_p_i_bus.html#a9409b30b42eee3a5ada64fd35104ee36">Open</a> (<a class="el" href="class_i_pv_device_adapter.html">IPvDeviceAdapter</a> *aDevice, <a class="el" href="_pv_device_serial_port_8h.html#adeba0547adb097b5eced5b7145f51bbe">PvDeviceSerial</a> aPort=<a class="el" href="_pv_device_serial_port_8h.html#adeba0547adb097b5eced5b7145f51bbea0fd72f18959d75d4dcf64134329fffa7">PvDeviceSerialBulk0</a>)</td></tr>
<tr class="memdesc:a9409b30b42eee3a5ada64fd35104ee36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open an SPI channel to the device on given port.  <a href="#a9409b30b42eee3a5ada64fd35104ee36">More...</a><br/></td></tr>
<tr class="separator:a9409b30b42eee3a5ada64fd35104ee36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362747beddd2fa40e31e16a027ca01e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_device_s_p_i_bus.html#a362747beddd2fa40e31e16a027ca01e8">Close</a> ()</td></tr>
<tr class="memdesc:a362747beddd2fa40e31e16a027ca01e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the SPI channel to the device.  <a href="#a362747beddd2fa40e31e16a027ca01e8">More...</a><br/></td></tr>
<tr class="separator:a362747beddd2fa40e31e16a027ca01e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbaf5ba7777ffbaf9b5a48658fec396f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_device_s_p_i_bus.html#acbaf5ba7777ffbaf9b5a48658fec396f">IsOpened</a> ()</td></tr>
<tr class="memdesc:acbaf5ba7777ffbaf9b5a48658fec396f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether SPI is opened or not.  <a href="#acbaf5ba7777ffbaf9b5a48658fec396f">More...</a><br/></td></tr>
<tr class="separator:acbaf5ba7777ffbaf9b5a48658fec396f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a2e6647ab23d60ce23c23824ee7aa8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_device_s_p_i_bus.html#a0a2e6647ab23d60ce23c23824ee7aa8c">BurstRead</a> (unsigned char *aBuffer, uint32_t aBufferSize, uint32_t &amp;aBytesRead, uint32_t aTimeout=0)</td></tr>
<tr class="memdesc:a0a2e6647ab23d60ce23c23824ee7aa8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve bytes read back from a device.  <a href="#a0a2e6647ab23d60ce23c23824ee7aa8c">More...</a><br/></td></tr>
<tr class="separator:a0a2e6647ab23d60ce23c23824ee7aa8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2da48f8c71e135432b09618df00a5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_device_s_p_i_bus.html#a6d2da48f8c71e135432b09618df00a5d">BurstWriteAndRead</a> (unsigned char *aWriteBuffer, uint32_t aWriteBufferSize, uint32_t aReadBufferSize=0, bool aWriteRead=false, bool aSSNFlagOn=false)</td></tr>
<tr class="memdesc:a6d2da48f8c71e135432b09618df00a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a command to the camera and/or expect data back for maximum transfers of 255 bytes.  <a href="#a6d2da48f8c71e135432b09618df00a5d">More...</a><br/></td></tr>
<tr class="separator:a6d2da48f8c71e135432b09618df00a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a5e8e6af30ebfe7a0c8a60de94bde4ebd"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_device_s_p_i_bus.html#a5e8e6af30ebfe7a0c8a60de94bde4ebd">IsSupported</a> (<a class="el" href="class_i_pv_device_adapter.html">IPvDeviceAdapter</a> *aDevice, <a class="el" href="_pv_device_serial_port_8h.html#adeba0547adb097b5eced5b7145f51bbe">PvDeviceSerial</a> aPort=<a class="el" href="_pv_device_serial_port_8h.html#adeba0547adb097b5eced5b7145f51bbea0fd72f18959d75d4dcf64134329fffa7">PvDeviceSerialBulk0</a>)</td></tr>
<tr class="memdesc:a5e8e6af30ebfe7a0c8a60de94bde4ebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether the device supports SPI and if it is available. The device should be connected. The BulkSelector of the device should be set appropriately (e.g. if SPI is supposed to be on Bulk0, then BulkSelector should be set to Bulk0, otherwise even if the device supports SPI, this function will return false). Consult with device documentation on when and on which port SPI is supported and available.  <a href="#a5e8e6af30ebfe7a0c8a60de94bde4ebd">More...</a><br/></td></tr>
<tr class="separator:a5e8e6af30ebfe7a0c8a60de94bde4ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>SPI serial controller. </p>
<p>The <a class="el" href="class_pv_device_s_p_i_bus.html" title="SPI serial controller. ">PvDeviceSPIBus</a> lets you send commands to your camera and receive the camera's replies.</p>
<p>SPI uses the concept of a master and slave, where the master controls the clock and initiates reads and writes. For <a class="el" href="class_pv_device_s_p_i_bus.html" title="SPI serial controller. ">PvDeviceSPIBus</a>, the IP Engine is the SPI master. The SPI slave is <em>typically</em> a camera, but could be any SPI-capable device connected to the IP Engine.</p>
<p>The <a class="el" href="class_pv_device_s_p_i_bus.html" title="SPI serial controller. ">PvDeviceSPIBus</a> methods manage the entire IP Engine and camera communication required to send a message to the camera. It does not however do the configuration and setting the mode to SPI (these should be done through the GenICam interface before write/read functions are called). For example if SPI is on Bulk0, then BulkSelector needs to be set to Bulk0 The <a class="el" href="class_pv_device_s_p_i_bus.html#a6d2da48f8c71e135432b09618df00a5d" title="Send a command to the camera and/or expect data back for maximum transfers of 255 bytes...">BurstWriteAndRead</a> can be used to :</p>
<ol type="1">
<li>Write a set of bytes to SPI; no data is expected to be read back</li>
<li>write only but have SS_N flag on</li>
<li>read only</li>
<li>write read simultaneously</li>
</ol>
<p>For the complete hardware-level transactions for all <a class="el" href="class_pv_device_s_p_i_bus.html" title="SPI serial controller. ">PvDeviceSPIBus</a> methods, see your hardware guide.</p>
<p><b>To send SPI-protocol serial commands to your camera:</b></p>
<ol type="1">
<li>Using GenICam interface, set the device in SPI mode (e.g. BulkSelector=Bulk0, BulkMode=SPI if this is what the documentation suggests)</li>
<li>Create an SPI serial controller. Use <a class="el" href="class_pv_device_s_p_i_bus.html#a3f4b3e5fffa20f3d9e2da5caccaf2f24" title="Constructor. ">PvDeviceSPIBus::PvDeviceSPIBus</a>.</li>
<li>Send a command to the camera. Use <a class="el" href="class_pv_device_s_p_i_bus.html#a6d2da48f8c71e135432b09618df00a5d" title="Send a command to the camera and/or expect data back for maximum transfers of 255 bytes...">BurstWriteAndRead</a></li>
<li>Test to ensure the message send succeeded. Check the <a class="el" href="class_pv_result.html" title="Result information. ">PvResult</a> returned by <a class="el" href="class_pv_device_s_p_i_bus.html#a6d2da48f8c71e135432b09618df00a5d" title="Send a command to the camera and/or expect data back for maximum transfers of 255 bytes...">BurstWriteAndRead</a></li>
<li>Retrieve the camera's reply. Use <a class="el" href="class_pv_device_s_p_i_bus.html#a0a2e6647ab23d60ce23c23824ee7aa8c" title="Retrieve bytes read back from a device. ">BurstRead</a>.</li>
<li>Test to ensure the message retrieval succeeded. Check the <a class="el" href="class_pv_result.html" title="Result information. ">PvResult</a> returned by <a class="el" href="class_pv_device_s_p_i_bus.html#a0a2e6647ab23d60ce23c23824ee7aa8c" title="Retrieve bytes read back from a device. ">BurstRead</a>.</li>
<li>Test the <em>content</em> of the message from the camera. Use <em>aBuffer</em> and <em>aBufferSize</em> parameters and your own code.</li>
</ol>
<p>For a simple example illustrating how to use <a class="el" href="class_pv_device_s_p_i_bus.html" title="SPI serial controller. ">PvDeviceSPIBus</a>, refer to the sample entitled PvSPISample. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a0a2e6647ab23d60ce23c23824ee7aa8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvDeviceSPIBus::BurstRead </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>aBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>aBytesRead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aTimeout</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve bytes read back from a device. </p>
<p>Wait <em>aTimeOut<em> milliseconds for the data read. The data read should have been initiated by either a ReadOnly or WriteRead using <a class="el" href="class_pv_device_s_p_i_bus.html#a6d2da48f8c71e135432b09618df00a5d" title="Send a command to the camera and/or expect data back for maximum transfers of 255 bytes...">BurstWriteAndRead</a></em></em></p>
<p><em><em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">aBuffer</td><td>A pointer to the data being received from the camera. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aBufferSize</td><td>The buffer's anticipated size. <a class="el" href="class_pv_device_s_p_i_bus.html#a0a2e6647ab23d60ce23c23824ee7aa8c" title="Retrieve bytes read back from a device. ">BurstRead</a> never returns with a buffer size larger than the originally specified <em>aBufferSize</em>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aBytesRead</td><td>The number of bytes read. Maximum of 255 bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aTimeout</td><td>Time out in milliseconds before returning if no data is received</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_pv_result.html" title="Result information. ">PvResult</a> </dd></dl>
<p></em></em></p>

</div>
</div>
<a class="anchor" id="a6d2da48f8c71e135432b09618df00a5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvDeviceSPIBus::BurstWriteAndRead </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>aWriteBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aWriteBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aReadBufferSize</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>aWriteRead</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>aSSNFlagOn</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a command to the camera and/or expect data back for maximum transfers of 255 bytes. </p>
<p>The <a class="el" href="class_pv_device_s_p_i_bus.html#a6d2da48f8c71e135432b09618df00a5d" title="Send a command to the camera and/or expect data back for maximum transfers of 255 bytes...">BurstWriteAndRead</a> method sends a message, <em>aBuffer</em>, to the SPI-capable camera and or expects <em>aReadBufferSize<em> bytes to come back (read). There are four modes: 1) Write-Only: Write <em>aWriteBufferSize<em> bytes to SPI. Can hold SSNFlagOn high. <em>aWriteRead<em> should be false <em>aReadBufferSize<em> should be 0 2) Read-Only: schedule a read of <em>aReadBufferSize<em> bytes. <em>aWriteBufferSize<em> is 0. No write is done, but a read is scheduled 3) Write-Read: N bytes are written while M bytes are read back. <em>aWriteRead<em> and <em>aSSNFlagOn<em> should be false. 4) Write-Read: N bytes are written and read back. <em>aWriteRead<em> is true. <em>aSSNFlagOn<em> should be false</em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></p>
<p><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aWriteBuffer</td><td>A pointer to the data being sent to the camera. is ignored if Read-Only </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aWriteBufferSize</td><td>The write buffer's size. Should be 0 in Read-only mode, Maximum of 255 bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aReadBufferSize</td><td>Number of bytes to read back (0 for Write-Only mode), Maximum of 255 bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aWriteRead</td><td>true for Write-Read of same number of bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aSSNFlagOn</td><td>when in Write-Only mode, whether to keep SS_N flag on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_pv_result.html" title="Result information. ">PvResult</a> </dd></dl>
<p></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></p>

</div>
</div>
<a class="anchor" id="a362747beddd2fa40e31e16a027ca01e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvDeviceSPIBus::Close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close the SPI channel to the device. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_pv_result.html" title="Result information. ">PvResult</a> </dd></dl>

</div>
</div>
<a class="anchor" id="acbaf5ba7777ffbaf9b5a48658fec396f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PvDeviceSPIBus::IsOpened </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether SPI is opened or not. </p>
<dl class="section return"><dt>Returns</dt><dd>true if opened, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a5e8e6af30ebfe7a0c8a60de94bde4ebd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PvDeviceSPIBus::IsSupported </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv_device_adapter.html">IPvDeviceAdapter</a> *&#160;</td>
          <td class="paramname"><em>aDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_pv_device_serial_port_8h.html#adeba0547adb097b5eced5b7145f51bbe">PvDeviceSerial</a>&#160;</td>
          <td class="paramname"><em>aPort</em> = <code><a class="el" href="_pv_device_serial_port_8h.html#adeba0547adb097b5eced5b7145f51bbea0fd72f18959d75d4dcf64134329fffa7">PvDeviceSerialBulk0</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test whether the device supports SPI and if it is available. The device should be connected. The BulkSelector of the device should be set appropriately (e.g. if SPI is supposed to be on Bulk0, then BulkSelector should be set to Bulk0, otherwise even if the device supports SPI, this function will return false). Consult with device documentation on when and on which port SPI is supported and available. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aDevice</td><td>A pointer to connected device to test support for SPI </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aPort</td><td>Port to check support for SPI (Bulk0 default if not specified)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if SPI is supported and available </dd></dl>

</div>
</div>
<a class="anchor" id="a9409b30b42eee3a5ada64fd35104ee36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvDeviceSPIBus::Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_pv_device_adapter.html">IPvDeviceAdapter</a> *&#160;</td>
          <td class="paramname"><em>aDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_pv_device_serial_port_8h.html#adeba0547adb097b5eced5b7145f51bbe">PvDeviceSerial</a>&#160;</td>
          <td class="paramname"><em>aPort</em> = <code><a class="el" href="_pv_device_serial_port_8h.html#adeba0547adb097b5eced5b7145f51bbea0fd72f18959d75d4dcf64134329fffa7">PvDeviceSerialBulk0</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open an SPI channel to the device on given port. </p>
<p><em>aDevice<em> should be connected already. Will return error if device is not connect or SPI is not supported or unavailable Note that the BulkSelector and BulkMode registers should be set appropriately before calling open. For example if SPI is supported on Bulk0, then BulkSelector should be set to Bulk0 and BulkMode set to SPI before calling open. Open does not set these. In other words, it is assumed that the bulk mode has been set to SPI already using GenICam Interface before open is called</em></em></p>
<p><em><em></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aDevice</td><td>A pointer to connected device to open an SPI channel to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aPort</td><td>Port to use for SPI (Bulk0 default if not specified)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_pv_result.html" title="Result information. ">PvResult</a> will return error if device is not connected or SPI is not supported or unavailable </dd></dl>
<p></em></em></p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_pv_device_s_p_i_bus_8h_source.html">PvDeviceSPIBus.h</a></li>
<li>PvDeviceSPIBus.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr size="1">
<P><B>Copyright (c) 2002-2015 Pleora Technologies Inc.</B><BR>
<a href="http://www.pleora.com" target="_blank">www.pleora.com</a></P>
</body>
</html>

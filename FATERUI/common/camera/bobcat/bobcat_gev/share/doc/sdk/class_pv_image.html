<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
		<title>PvImage Class Reference</title>
		<link href="doxygen.css" rel="stylesheet" type="text/css">
		<link href="tabs.css" rel="stylesheet" type="text/css">
	</head>
	<body>
	<div class="contents">
		<div class="textblock">
			<h2><a href="http://www.pleora.com" target="_blank"><img src="logo.jpg" alt="Pleora Technologies Inc." align="middle" border="0"></a>
			eBUS SDK v4.1.4.3606 API</h2>
		</div>
	</div>
	<br>
	<br>
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_pv_image.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_pv_image-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PvImage Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Image interface to a <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a>.  
 <a href="class_pv_image.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adb2e097ca04801c82031ec6940b42beb"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#adb2e097ca04801c82031ec6940b42beb">GetDataPointer</a> () const </td></tr>
<tr class="memdesc:adb2e097ca04801c82031ec6940b42beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the buffer's data pointer.  <a href="#adb2e097ca04801c82031ec6940b42beb">More...</a><br/></td></tr>
<tr class="separator:adb2e097ca04801c82031ec6940b42beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf3534bc5e5896eb950a3203b215128"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#a4cf3534bc5e5896eb950a3203b215128">GetDataPointer</a> ()</td></tr>
<tr class="memdesc:a4cf3534bc5e5896eb950a3203b215128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the buffer's data pointer.  <a href="#a4cf3534bc5e5896eb950a3203b215128">More...</a><br/></td></tr>
<tr class="separator:a4cf3534bc5e5896eb950a3203b215128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4091630b68604e1a7045f301c1f220c0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#a4091630b68604e1a7045f301c1f220c0">GetWidth</a> () const </td></tr>
<tr class="memdesc:a4091630b68604e1a7045f301c1f220c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the image's width.  <a href="#a4091630b68604e1a7045f301c1f220c0">More...</a><br/></td></tr>
<tr class="separator:a4091630b68604e1a7045f301c1f220c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4dbc5fd430621436c1598e2ee96ba65"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#ab4dbc5fd430621436c1598e2ee96ba65">GetHeight</a> () const </td></tr>
<tr class="memdesc:ab4dbc5fd430621436c1598e2ee96ba65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the image's height.  <a href="#ab4dbc5fd430621436c1598e2ee96ba65">More...</a><br/></td></tr>
<tr class="separator:ab4dbc5fd430621436c1598e2ee96ba65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2d56d675f0dd65e983b109b165ba26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#a7f2d56d675f0dd65e983b109b165ba26">GetPixelType</a> () const </td></tr>
<tr class="memdesc:a7f2d56d675f0dd65e983b109b165ba26"><td class="mdescLeft">&#160;</td><td class="mdescRight">The buffer's GigE Vision pixel type.  <a href="#a7f2d56d675f0dd65e983b109b165ba26">More...</a><br/></td></tr>
<tr class="separator:a7f2d56d675f0dd65e983b109b165ba26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e2710bc38d5a20c11ac1ca4e5728eb"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#a00e2710bc38d5a20c11ac1ca4e5728eb">GetBitsPerPixel</a> () const </td></tr>
<tr class="memdesc:a00e2710bc38d5a20c11ac1ca4e5728eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns how many bits are required to hold a pixel using the current buffer's pixel type.  <a href="#a00e2710bc38d5a20c11ac1ca4e5728eb">More...</a><br/></td></tr>
<tr class="separator:a00e2710bc38d5a20c11ac1ca4e5728eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e64849eefbcd6d41e3b3c56c88406a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#ae1e64849eefbcd6d41e3b3c56c88406a">GetRequiredSize</a> () const </td></tr>
<tr class="memdesc:ae1e64849eefbcd6d41e3b3c56c88406a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of buffer required to hold the acquired image.  <a href="#ae1e64849eefbcd6d41e3b3c56c88406a">More...</a><br/></td></tr>
<tr class="separator:ae1e64849eefbcd6d41e3b3c56c88406a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef8789957e99a83b07747128e8c9f85"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#adef8789957e99a83b07747128e8c9f85">GetImageSize</a> () const </td></tr>
<tr class="memdesc:adef8789957e99a83b07747128e8c9f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actual image size within the payload or buffer.  <a href="#adef8789957e99a83b07747128e8c9f85">More...</a><br/></td></tr>
<tr class="separator:adef8789957e99a83b07747128e8c9f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8145ff48ae7b05fb412aa7f6d3fdf32"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#ab8145ff48ae7b05fb412aa7f6d3fdf32">GetEffectiveImageSize</a> () const </td></tr>
<tr class="memdesc:ab8145ff48ae7b05fb412aa7f6d3fdf32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Effective image size.  <a href="#ab8145ff48ae7b05fb412aa7f6d3fdf32">More...</a><br/></td></tr>
<tr class="separator:ab8145ff48ae7b05fb412aa7f6d3fdf32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ace5c9515129b1459c7b26f0998ebc6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#a5ace5c9515129b1459c7b26f0998ebc6">GetOffsetX</a> () const </td></tr>
<tr class="memdesc:a5ace5c9515129b1459c7b26f0998ebc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the image's horizontal offset.  <a href="#a5ace5c9515129b1459c7b26f0998ebc6">More...</a><br/></td></tr>
<tr class="separator:a5ace5c9515129b1459c7b26f0998ebc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35d8c2ef8f857efe2a81f1b1db92aae9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#a35d8c2ef8f857efe2a81f1b1db92aae9">GetOffsetY</a> () const </td></tr>
<tr class="memdesc:a35d8c2ef8f857efe2a81f1b1db92aae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the image's vertical offset.  <a href="#a35d8c2ef8f857efe2a81f1b1db92aae9">More...</a><br/></td></tr>
<tr class="separator:a35d8c2ef8f857efe2a81f1b1db92aae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53e533711d389ae1e82e6141f85e20c0"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#a53e533711d389ae1e82e6141f85e20c0">GetPaddingX</a> () const </td></tr>
<tr class="memdesc:a53e533711d389ae1e82e6141f85e20c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the horizontal image padding.  <a href="#a53e533711d389ae1e82e6141f85e20c0">More...</a><br/></td></tr>
<tr class="separator:a53e533711d389ae1e82e6141f85e20c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89519fdae38495fe26b3b7a85dfab2b6"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#a89519fdae38495fe26b3b7a85dfab2b6">GetPaddingY</a> () const </td></tr>
<tr class="memdesc:a89519fdae38495fe26b3b7a85dfab2b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the vertical image padding.  <a href="#a89519fdae38495fe26b3b7a85dfab2b6">More...</a><br/></td></tr>
<tr class="separator:a89519fdae38495fe26b3b7a85dfab2b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd3629be8f2d537822d2af74d717034"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#abdd3629be8f2d537822d2af74d717034">Alloc</a> (uint32_t aSizeX, uint32_t aSizeY, <a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a> aPixelType, uint16_t aPaddingX=0, uint16_t aPaddingY=0)</td></tr>
<tr class="memdesc:abdd3629be8f2d537822d2af74d717034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for this <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer. ">PvImage</a>.  <a href="#abdd3629be8f2d537822d2af74d717034">More...</a><br/></td></tr>
<tr class="separator:abdd3629be8f2d537822d2af74d717034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae016c1a96c54cf47cc7bd5c2fbcdfb05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#ae016c1a96c54cf47cc7bd5c2fbcdfb05">Free</a> ()</td></tr>
<tr class="memdesc:ae016c1a96c54cf47cc7bd5c2fbcdfb05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees (de-allocates) the buffer's internal memory.  <a href="#ae016c1a96c54cf47cc7bd5c2fbcdfb05">More...</a><br/></td></tr>
<tr class="separator:ae016c1a96c54cf47cc7bd5c2fbcdfb05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b24ae29c2279abe96c0b3b051e0f4c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_result.html">PvResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#a5b24ae29c2279abe96c0b3b051e0f4c2">Attach</a> (void *aRawBuffer, uint32_t aSizeX, uint32_t aSizeY, <a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a> aPixelType, uint16_t aPaddingX=0, uint16_t aPaddingY=0)</td></tr>
<tr class="memdesc:a5b24ae29c2279abe96c0b3b051e0f4c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach this <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer. ">PvImage</a> to an external memory buffer.  <a href="#a5b24ae29c2279abe96c0b3b051e0f4c2">More...</a><br/></td></tr>
<tr class="separator:a5b24ae29c2279abe96c0b3b051e0f4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553a49decc4dc736918d710313a39ca3"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#a553a49decc4dc736918d710313a39ca3">Detach</a> ()</td></tr>
<tr class="memdesc:a553a49decc4dc736918d710313a39ca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases an attached memory buffer.  <a href="#a553a49decc4dc736918d710313a39ca3">More...</a><br/></td></tr>
<tr class="separator:a553a49decc4dc736918d710313a39ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae54ac33c2fa453c0054a544344e7e94a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#ae54ac33c2fa453c0054a544344e7e94a">IsPartialLineMissing</a> () const </td></tr>
<tr class="memdesc:ae54ac33c2fa453c0054a544344e7e94a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true, the grabber (on the device) was missing at least one pixel in at least one of the lines when the frame was grabbed.  <a href="#ae54ac33c2fa453c0054a544344e7e94a">More...</a><br/></td></tr>
<tr class="separator:ae54ac33c2fa453c0054a544344e7e94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1d758e7bf35449eb5f41cacd929e73"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#a2e1d758e7bf35449eb5f41cacd929e73">IsFullLineMissing</a> () const </td></tr>
<tr class="memdesc:a2e1d758e7bf35449eb5f41cacd929e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true, the grabber (on the device) was missing at least one line when the frame was grabbed.  <a href="#a2e1d758e7bf35449eb5f41cacd929e73">More...</a><br/></td></tr>
<tr class="separator:a2e1d758e7bf35449eb5f41cacd929e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5608b83f6224fa83a2e5e999571a9e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#aa5608b83f6224fa83a2e5e999571a9e8">IsEOFByLineCount</a> () const </td></tr>
<tr class="memdesc:aa5608b83f6224fa83a2e5e999571a9e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of Frame by Line Count status bit.  <a href="#aa5608b83f6224fa83a2e5e999571a9e8">More...</a><br/></td></tr>
<tr class="separator:aa5608b83f6224fa83a2e5e999571a9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8718211474c412cabe75039611921018"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#a8718211474c412cabe75039611921018">IsInterlacedEven</a> () const </td></tr>
<tr class="memdesc:a8718211474c412cabe75039611921018"><td class="mdescLeft">&#160;</td><td class="mdescRight">The image contained in the <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer. ">PvImage</a> is an interlaced Even field.  <a href="#a8718211474c412cabe75039611921018">More...</a><br/></td></tr>
<tr class="separator:a8718211474c412cabe75039611921018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7960389da1221f18df7d065f3ced79a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#ab7960389da1221f18df7d065f3ced79a">IsInterlacedOdd</a> () const </td></tr>
<tr class="memdesc:ab7960389da1221f18df7d065f3ced79a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The image contained in the <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer. ">PvImage</a> is an interlaced Odd field.  <a href="#ab7960389da1221f18df7d065f3ced79a">More...</a><br/></td></tr>
<tr class="separator:ab7960389da1221f18df7d065f3ced79a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d83aab9a0ce7751fd08f285c756ab6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#a12d83aab9a0ce7751fd08f285c756ab6">IsImageDropped</a> () const </td></tr>
<tr class="memdesc:a12d83aab9a0ce7751fd08f285c756ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Image dropped status bit.  <a href="#a12d83aab9a0ce7751fd08f285c756ab6">More...</a><br/></td></tr>
<tr class="separator:a12d83aab9a0ce7751fd08f285c756ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6bf65577c43c8eed78ef60336cbd8d7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#ad6bf65577c43c8eed78ef60336cbd8d7">IsDataOverrun</a> () const </td></tr>
<tr class="memdesc:ad6bf65577c43c8eed78ef60336cbd8d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data overrun status bit.  <a href="#ad6bf65577c43c8eed78ef60336cbd8d7">More...</a><br/></td></tr>
<tr class="separator:ad6bf65577c43c8eed78ef60336cbd8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3897e08abb8c6e681ee22f07115cb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pv_buffer.html">PvBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#a1f3897e08abb8c6e681ee22f07115cb9">GetBuffer</a> ()</td></tr>
<tr class="memdesc:a1f3897e08abb8c6e681ee22f07115cb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> this <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer. ">PvImage</a> belongs to.  <a href="#a1f3897e08abb8c6e681ee22f07115cb9">More...</a><br/></td></tr>
<tr class="separator:a1f3897e08abb8c6e681ee22f07115cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aff436f997e7bf40a79a8972e186130ef"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#aff436f997e7bf40a79a8972e186130ef">GetPixelSize</a> (<a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a> aPixelType)</td></tr>
<tr class="memdesc:aff436f997e7bf40a79a8972e186130ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static method returning the pixel size in bits for a specific pixel type.  <a href="#aff436f997e7bf40a79a8972e186130ef">More...</a><br/></td></tr>
<tr class="separator:aff436f997e7bf40a79a8972e186130ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe9d41a325260130856f7c1e24dc5996"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#afe9d41a325260130856f7c1e24dc5996">IsPixelColor</a> (<a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a> aPixelType)</td></tr>
<tr class="memdesc:afe9d41a325260130856f7c1e24dc5996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static method returning whether a pixel type is color or not.  <a href="#afe9d41a325260130856f7c1e24dc5996">More...</a><br/></td></tr>
<tr class="separator:afe9d41a325260130856f7c1e24dc5996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819302e1e982f867941a5bf11ce248ec"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#a819302e1e982f867941a5bf11ce248ec">IsPixelHighRes</a> (<a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a> aPixelType)</td></tr>
<tr class="memdesc:a819302e1e982f867941a5bf11ce248ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static method returning whether a pixel type is higher than 8-bit per channel or not.  <a href="#a819302e1e982f867941a5bf11ce248ec">More...</a><br/></td></tr>
<tr class="separator:a819302e1e982f867941a5bf11ce248ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac14e08fb6c14614f1f0f78d5ccad129"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#aac14e08fb6c14614f1f0f78d5ccad129">GetBitsPerComponent</a> (<a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a> aPixelType)</td></tr>
<tr class="memdesc:aac14e08fb6c14614f1f0f78d5ccad129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static method returning the number of bit per components for a pixel type.  <a href="#aac14e08fb6c14614f1f0f78d5ccad129">More...</a><br/></td></tr>
<tr class="separator:aac14e08fb6c14614f1f0f78d5ccad129"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:abc9db34b921323fdc18bec63e4a7ae4e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#abc9db34b921323fdc18bec63e4a7ae4e">PvImage</a> (PvBufferLib::Image *aImage)</td></tr>
<tr class="memdesc:abc9db34b921323fdc18bec63e4a7ae4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#abc9db34b921323fdc18bec63e4a7ae4e">More...</a><br/></td></tr>
<tr class="separator:abc9db34b921323fdc18bec63e4a7ae4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e8bb7b4629973a40fb17923da29c548"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pv_image.html#a3e8bb7b4629973a40fb17923da29c548">~PvImage</a> ()</td></tr>
<tr class="memdesc:a3e8bb7b4629973a40fb17923da29c548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a3e8bb7b4629973a40fb17923da29c548">More...</a><br/></td></tr>
<tr class="separator:a3e8bb7b4629973a40fb17923da29c548"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a41f14acd0cb6c490187a1b9adeac7774"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41f14acd0cb6c490187a1b9adeac7774"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>PvTruesenseConverter</b></td></tr>
<tr class="separator:a41f14acd0cb6c490187a1b9adeac7774"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Image interface to a <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a>. </p>
<p>A <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> represents a generic buffer with no specific payload type. If the payload type is image, the user can obtain a pointer to a <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer. ">PvImage</a> buffer interface through <a class="el" href="class_pv_buffer.html#aa0e84f98d2c01c33aa6d58343fc242fc" title="Returns the PvImage interface to the buffer. ">PvBuffer::GetImage</a>.</p>
<p>This <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer. ">PvImage</a> pointer is owned by the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> and does not need to be released after use. It is valid as long as the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> exists.</p>
<h2 id="accessing">Accessing image specific data</h2>
<p><b>To determinate the payload type and access image specific data:</b></p>
<ol type="1">
<li>Retrieve the <a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30f" title="GVSP payload type. ">PvPayloadType</a> using <a class="el" href="class_pv_buffer.html#af12443f42dd7cc60f6f158cc0b433122" title="Returns the payload type currently used by the buffer. ">PvBuffer::GetPayloadType</a></li>
<li>If <a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30f" title="GVSP payload type. ">PvPayloadType</a> is <a class="el" href="_pv_payload_type_8h.html#a6c1e34101dca065563eb3ed4694ba30faeb97a52f2036290b6213951f7782c841">PvPayloadTypeImage</a>, retrieve <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer. ">PvImage</a> pointer from your <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a></li>
<li>Access image specific data through the <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer. ">PvImage</a> pointer, like <a class="el" href="class_pv_image.html#a4091630b68604e1a7045f301c1f220c0" title="Get the image&#39;s width. ">PvImage::GetWidth</a>, <a class="el" href="class_pv_image.html#ab4dbc5fd430621436c1598e2ee96ba65" title="Get the image&#39;s height. ">PvImage::GetHeight</a>, etc.</li>
<li>There is no need to release or delete the <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer. ">PvImage</a> pointer. It is valid as long as the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> exists. </li>
</ol>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="abc9db34b921323fdc18bec63e4a7ae4e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PvImage::PvImage </td>
          <td>(</td>
          <td class="paramtype">PvBufferLib::Image *&#160;</td>
          <td class="paramname"><em>aImage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Declared as protected as <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer. ">PvImage</a> cannot be instantiated by the user.</p>
<p>A pointer to the <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer. ">PvImage</a> interface can be obtained from a <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> using <a class="el" href="class_pv_buffer.html#aa0e84f98d2c01c33aa6d58343fc242fc" title="Returns the PvImage interface to the buffer. ">PvBuffer::GetImage</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aImage</td><td>Pointer to internal PureGEV class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3e8bb7b4629973a40fb17923da29c548"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PvImage::~PvImage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Declared as protected as the user does no need (or can) delete a <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer. ">PvImage</a> directly. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="abdd3629be8f2d537822d2af74d717034"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvImage::Alloc </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aSizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aSizeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a>&#160;</td>
          <td class="paramname"><em>aPixelType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>aPaddingX</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>aPaddingY</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory for this <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer. ">PvImage</a>. </p>
<p>Allocs a <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer. ">PvImage</a> of specific width, height and pixel format</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aSizeX</td><td>The width of the image, in pixels. See <a class="el" href="class_pv_image.html#a4091630b68604e1a7045f301c1f220c0" title="Get the image&#39;s width. ">GetWidth</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aSizeY</td><td>The height of the image, in pixels. See <a class="el" href="class_pv_image.html#ab4dbc5fd430621436c1598e2ee96ba65" title="Get the image&#39;s height. ">GetHeight</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aPixelType</td><td>The GEV pixel type from which the pixel depth is extracted. For supported pixel types, see <a class="el" href="_pv_pixel_type_8h.html">PvPixelType.h</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aPaddingX</td><td>The horizontal padding of the image, in pixels. See <a class="el" href="class_pv_image.html#a53e533711d389ae1e82e6141f85e20c0" title="Get the horizontal image padding. ">GetPaddingX</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aPaddingY</td><td>The vertical padding of the image, in pixels. See <a class="el" href="class_pv_image.html#a89519fdae38495fe26b3b7a85dfab2b6" title="Get the vertical image padding. ">GetPaddingY</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7cac194e39fb420655ac75525f53714bc2c">PvResult::Code::NOT_ENOUGH_MEMORY</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a5b24ae29c2279abe96c0b3b051e0f4c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_result.html">PvResult</a> PvImage::Attach </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>aRawBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aSizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aSizeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a>&#160;</td>
          <td class="paramname"><em>aPixelType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>aPaddingX</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>aPaddingY</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attach this <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer. ">PvImage</a> to an external memory buffer. </p>
<p>This method is identical to <a class="el" href="class_pv_image.html#abdd3629be8f2d537822d2af74d717034" title="Allocates memory for this PvImage. ">Alloc(uint32_t,uint32_t,PvPixelType,uint16_t,uint16_t)</a>, with the following exceptions:</p>
<ul>
<li>This method uses an external memory buffer, controlled by the caller.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aRawBuffer</td><td>A pointer to the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aSizeX</td><td>See <a class="el" href="class_pv_image.html#abdd3629be8f2d537822d2af74d717034" title="Allocates memory for this PvImage. ">Alloc(uint32_t,uint32_t,PvPixelType,uint16_t,uint16_t)</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aSizeY</td><td>See <a class="el" href="class_pv_image.html#abdd3629be8f2d537822d2af74d717034" title="Allocates memory for this PvImage. ">Alloc(uint32_t,uint32_t,PvPixelType,uint16_t,uint16_t)</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aPixelType</td><td>See <a class="el" href="class_pv_image.html#abdd3629be8f2d537822d2af74d717034" title="Allocates memory for this PvImage. ">Alloc(uint32_t,uint32_t,PvPixelType,uint16_t,uint16_t)</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aPaddingX</td><td>See <a class="el" href="class_pv_image.html#abdd3629be8f2d537822d2af74d717034" title="Allocates memory for this PvImage. ">Alloc(uint32_t,uint32_t,PvPixelType,uint16_t,uint16_t)</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aPaddingY</td><td>See <a class="el" href="class_pv_image.html#abdd3629be8f2d537822d2af74d717034" title="Allocates memory for this PvImage. ">Alloc(uint32_t,uint32_t,PvPixelType,uint16_t,uint16_t)</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Includes:<ul>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7ca70710a0a7cc21fcba9e37b910e73c4c9">PvResult::Code::OK</a></li>
<li><a class="el" href="struct_pv_result_1_1_code.html#af1274e2b903976bfd04c45b84341ec7caa01691a7ea2f9fd92fb720c5477bcda1">PvResult::Code::INVALID_PARAMETER</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a553a49decc4dc736918d710313a39ca3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t * PvImage::Detach </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases an attached memory buffer. </p>
<p>Does nothing other then resetting the memory buffer pointer to NULL.</p>
<dl class="section return"><dt>Returns</dt><dd>The buffer's location in memory.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_pv_image.html#a5b24ae29c2279abe96c0b3b051e0f4c2" title="Attach this PvImage to an external memory buffer. ">Attach</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae016c1a96c54cf47cc7bd5c2fbcdfb05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PvImage::Free </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees (de-allocates) the buffer's internal memory. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_pv_image.html#abdd3629be8f2d537822d2af74d717034" title="Allocates memory for this PvImage. ">Alloc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aac14e08fb6c14614f1f0f78d5ccad129"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvImage::GetBitsPerComponent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a>&#160;</td>
          <td class="paramname"><em>aPixelType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static method returning the number of bit per components for a pixel type. </p>
<p>PvPixelMono8 and PvPixelRGBa8 would be 8. Mono16, PvPixelRGB16, PvPixelBayerRG16 would be 16, etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aPixelType</td><td>Pixel type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if higher than 8 bit per channel. </dd></dl>

</div>
</div>
<a class="anchor" id="a00e2710bc38d5a20c11ac1ca4e5728eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvImage::GetBitsPerPixel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns how many bits are required to hold a pixel using the current buffer's pixel type. </p>
<dl class="section return"><dt>Returns</dt><dd>Bits per pixel for the current buffer's pixel type. </dd></dl>

</div>
</div>
<a class="anchor" id="a1f3897e08abb8c6e681ee22f07115cb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pv_buffer.html">PvBuffer</a> * PvImage::GetBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a> this <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer. ">PvImage</a> belongs to. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a <a class="el" href="class_pv_buffer.html" title="Represents a block of GigE Vision or USB3 Vision data in memory. ">PvBuffer</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="adb2e097ca04801c82031ec6940b42beb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t * PvImage::GetDataPointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the buffer's data pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the memory pointer. </dd></dl>

</div>
</div>
<a class="anchor" id="a4cf3534bc5e5896eb950a3203b215128"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t * PvImage::GetDataPointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the buffer's data pointer. </p>
<p>Const version.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the memory pointer. </dd></dl>

</div>
</div>
<a class="anchor" id="ab8145ff48ae7b05fb412aa7f6d3fdf32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvImage::GetEffectiveImageSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Effective image size. </p>
<p>Uses same size x and y as <a class="el" href="class_pv_image.html#adef8789957e99a83b07747128e8c9f85" title="Actual image size within the payload or buffer. ">GetImageSize()</a> but excludes all padding.</p>
<dl class="section return"><dt>Returns</dt><dd>The effective image size </dd></dl>

</div>
</div>
<a class="anchor" id="ab4dbc5fd430621436c1598e2ee96ba65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvImage::GetHeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the image's height. </p>
<dl class="section return"><dt>Returns</dt><dd>The image's height, in pixels. </dd></dl>

</div>
</div>
<a class="anchor" id="adef8789957e99a83b07747128e8c9f85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvImage::GetImageSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Actual image size within the payload or buffer. </p>
<p>Uses the GEV leader for the actual width. Uses the GEV trailer for line count which is the actual height.</p>
<dl class="section return"><dt>Returns</dt><dd>The actual image size within the payload or buffer </dd></dl>

</div>
</div>
<a class="anchor" id="a5ace5c9515129b1459c7b26f0998ebc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvImage::GetOffsetX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the image's horizontal offset. </p>
<dl class="section return"><dt>Returns</dt><dd>The image's horizontal offset, in pixels. </dd></dl>

</div>
</div>
<a class="anchor" id="a35d8c2ef8f857efe2a81f1b1db92aae9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvImage::GetOffsetY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the image's vertical offset. </p>
<dl class="section return"><dt>Returns</dt><dd>The image's vertical offset, in pixels. </dd></dl>

</div>
</div>
<a class="anchor" id="a53e533711d389ae1e82e6141f85e20c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t PvImage::GetPaddingX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the horizontal image padding. </p>
<p>Images lines could be grabbed in increments of, let's say, 32 bytes. For an image 511 bytes across, the video interface adds a meaningless byte to make the line total 512 bytes (divisible by 32). In this case, the <em>paddingX</em> value would be 1 (byte).</p>
<p>Other GigE Vision devices may have different requirements on line length. Divible by 4, 8, 16, etc. or no specific limitations or requirements.</p>
<dl class="section return"><dt>Returns</dt><dd>The horizontal image padding, in bytes; the number of bytes at the end of an image's line that contain meaningless data. </dd></dl>

</div>
</div>
<a class="anchor" id="a89519fdae38495fe26b3b7a85dfab2b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t PvImage::GetPaddingY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the vertical image padding. </p>
<p>Additional bytes appended at the end of an image.</p>
<p>See <a class="el" href="class_pv_image.html#a53e533711d389ae1e82e6141f85e20c0" title="Get the horizontal image padding. ">GetPaddingX</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>The vertical image padding, in bytes.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_pv_image.html#a53e533711d389ae1e82e6141f85e20c0" title="Get the horizontal image padding. ">GetPaddingX</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aff436f997e7bf40a79a8972e186130ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvImage::GetPixelSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a>&#160;</td>
          <td class="paramname"><em>aPixelType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static method returning the pixel size in bits for a specific pixel type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aPixelType</td><td>Pixel type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pixel size, in bits. </dd></dl>

</div>
</div>
<a class="anchor" id="a7f2d56d675f0dd65e983b109b165ba26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a> PvImage::GetPixelType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The buffer's GigE Vision pixel type. </p>
<dl class="section return"><dt>Returns</dt><dd>The GigE Vision pixel type. The pixel depth, colorspace, and other information are coded into the value. </dd></dl>

</div>
</div>
<a class="anchor" id="ae1e64849eefbcd6d41e3b3c56c88406a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvImage::GetRequiredSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the size of buffer required to hold the acquired image. </p>
<p>This attribute is valid if the last image acquisition was successful or if it failed because the buffer was too small. It can be used to re-allocate the acquisition buffers if the acquisition failed because the buffer was too small.</p>
<p>The required size is only computed for the last image - based on the number of lines as provided in the GigE Vision streaming protocol trailer.</p>
<p>It is possible that with devices outputting images of varying length (like line scan cameras) that the last image required size may be smaller than the maximum possible size.</p>
<p>In order to be 100% sure of allocating buffers correctly, you should either hard code the buffer size to known big enough sizes or use the device GenICam GevPayloadSize parameter for dynamic cases.</p>
<dl class="section return"><dt>Returns</dt><dd>The size, in bytes, required to hold the image in this buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a4091630b68604e1a7045f301c1f220c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PvImage::GetWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the image's width. </p>
<dl class="section return"><dt>Returns</dt><dd>The image's width in pixels. </dd></dl>

</div>
</div>
<a class="anchor" id="ad6bf65577c43c8eed78ef60336cbd8d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PvImage::IsDataOverrun </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Data overrun status bit. </p>
<dl class="section return"><dt>Returns</dt><dd>True if there was a data overrun. False otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aa5608b83f6224fa83a2e5e999571a9e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PvImage::IsEOFByLineCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>End of Frame by Line Count status bit. </p>
<dl class="section return"><dt>Returns</dt><dd>True if previous frame was NOT the last one of a sequence of sub frames. False otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a2e1d758e7bf35449eb5f41cacd929e73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PvImage::IsFullLineMissing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If true, the grabber (on the device) was missing at least one line when the frame was grabbed. </p>
<dl class="section return"><dt>Returns</dt><dd>True if full lines were missing, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a12d83aab9a0ce7751fd08f285c756ab6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PvImage::IsImageDropped </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Image dropped status bit. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the previous frame was dropped. False otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a8718211474c412cabe75039611921018"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PvImage::IsInterlacedEven </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The image contained in the <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer. ">PvImage</a> is an interlaced Even field. </p>
<dl class="section return"><dt>Returns</dt><dd>True interlaced Even field. False otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ab7960389da1221f18df7d065f3ced79a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PvImage::IsInterlacedOdd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The image contained in the <a class="el" href="class_pv_image.html" title="Image interface to a PvBuffer. ">PvImage</a> is an interlaced Odd field. </p>
<dl class="section return"><dt>Returns</dt><dd>True interlaced Odd field. False otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ae54ac33c2fa453c0054a544344e7e94a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PvImage::IsPartialLineMissing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If true, the grabber (on the device) was missing at least one pixel in at least one of the lines when the frame was grabbed. </p>
<dl class="section return"><dt>Returns</dt><dd>True if at least one pixel was missing, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="afe9d41a325260130856f7c1e24dc5996"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PvImage::IsPixelColor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a>&#160;</td>
          <td class="paramname"><em>aPixelType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static method returning whether a pixel type is color or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aPixelType</td><td>Pixel type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if color. </dd></dl>

</div>
</div>
<a class="anchor" id="a819302e1e982f867941a5bf11ce248ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PvImage::IsPixelHighRes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_pv_pixel_type_8h.html#a4eff2844732aaf702350ce733654cac9">PvPixelType</a>&#160;</td>
          <td class="paramname"><em>aPixelType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static method returning whether a pixel type is higher than 8-bit per channel or not. </p>
<p>10, 12, 14 and 16-bit pixel type are considered high resolution. RGB8 counts as 8 so high resolution here means per channel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aPixelType</td><td>Pixel type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if higher than 8 bit per channel. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_pv_image_8h_source.html">PvImage.h</a></li>
<li>PvImage.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr size="1">
<P><B>Copyright (c) 2002-2015 Pleora Technologies Inc.</B><BR>
<a href="http://www.pleora.com" target="_blank">www.pleora.com</a></P>
</body>
</html>
